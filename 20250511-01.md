- **Cita√ß√£o**
  - **T√≠tulo**: When to Use Transient, Scoped, or Singleton in .NET Apps - Understanding Service Lifetimes
  - **Autor**: Mukesh Murugan
  - **Fonte**: codewithmukesh
  - **URL**: https://codewithmukesh.com/blog/when-to-use-transient-scoped-singleton-dotnet/
  - **Atualizado**: 31 de mar√ßo de 2025

---

# When to Use Transient, Scoped, or Singleton in .NET Apps - Understanding Service Lifetimes

Em qualquer aplica√ß√£o .NET moderna, a [Inje√ß√£o de Depend√™ncias](/blog/dependency-injection-in-aspnet-core-explained/) √© a base de como os servi√ßos s√£o interligados. Ela simplifica os testes, imp√µe a separa√ß√£o de responsabilidades e facilita a manuten√ß√£o do c√≥digo. Mas, no momento em que sua aplica√ß√£o come√ßa a crescer, voc√™ rapidamente se depara com uma pergunta que confunde at√© mesmo desenvolvedores experientes: por quanto tempo um servi√ßo deve existir?

Este n√£o √© apenas um detalhe t√©cnico ‚Äî afeta o comportamento do seu aplicativo sob carga, o gerenciamento da mem√≥ria e at√© mesmo o funcionamento correto dos seus servi√ßos. Escolher o tempo de vida incorreto pode introduzir bugs dif√≠ceis de rastrear e ainda mais dif√≠ceis de corrigir. A escolha certa, por outro lado, mant√©m tudo r√°pido, limpo e previs√≠vel.

Este artigo se concentra inteiramente nos tempos de vida de servi√ßo em .NET. Abordaremos as diferentes op√ß√µes dispon√≠veis, o que elas significam na pr√°tica e como tomar a decis√£o certa dependendo do seu caso de uso.

## O que s√£o tempos de vida de servi√ßo no .NET?

No .NET, o _tempo de vida do servi√ßo_ define por quanto tempo uma inst√¢ncia de um servi√ßo permanece ativa ap√≥s ser criada pelo cont√™iner de Inje√ß√£o de Depend√™ncia (DI) integrado. Sempre que voc√™ registra um servi√ßo, tamb√©m especifica seu tempo de vida. Isso informa ao sistema de DI se ele deve criar uma nova inst√¢ncia a cada vez, reutilizar a mesma em uma solicita√ß√£o ou mant√™-la por toda a vida √∫til da aplica√ß√£o.

Esse comportamento √© importante porque diferentes servi√ßos t√™m responsabilidades diferentes. Alguns s√£o leves e sem estado ‚Äî perfeitos para criar novas inst√¢ncias com frequ√™ncia. Outros gerenciam estado compartilhado ou recursos caros ‚Äî ideais para reutilizar a mesma inst√¢ncia.

O .NET oferece tr√™s tempos de vida integrados:

- Transit√≥rio
- Escopo
- Solteiro

Cada um serve a um prop√≥sito espec√≠fico, e usar o errado pode introduzir bugs sutis, problemas de desempenho ou vazamentos de mem√≥ria. Antes de analisarmos cada um deles em detalhes, √© importante entender por que esse conceito existe e como ele se encaixa no contexto geral do design de aplicativos.

## Por que a vida √∫til do servi√ßo √© importante

Os tempos de vida dos servi√ßos n√£o s√£o apenas detalhes de configura√ß√£o ‚Äî eles moldam o comportamento do seu aplicativo em tempo de execu√ß√£o. Cada vez que voc√™ injeta um servi√ßo, o cont√™iner DI decide se retorna uma nova inst√¢ncia, reutiliza uma existente ou compartilha uma √∫nica inst√¢ncia em todo o aplicativo. Essa decis√£o afeta o uso de mem√≥ria, a seguran√ßa de threads, a consist√™ncia dos dados e o isolamento das solicita√ß√µes.

Se um servi√ßo for registrado acidentalmente com o tempo de vida incorreto, as coisas podem dar errado rapidamente. Injetar um servi√ßo com escopo em um Singleton pode gerar exce√ß√µes de tempo de execu√ß√£o. Compartilhar um Singleton que cont√©m dados espec√≠ficos da solicita√ß√£o pode levar a condi√ß√µes de corrida. Criar muitos objetos Transient pode prejudicar o desempenho ou vazar recursos n√£o gerenciados.

Escolher o tempo de vida correto garante que seus servi√ßos sejam seguros, eficientes e sens√≠veis ao contexto. Tamb√©m ajuda a evitar bugs ocultos que s√≥ aparecem sob carga ou em produ√ß√£o. Antes de escrever ou registrar qualquer servi√ßo, voc√™ precisa pensar por quanto tempo ele deve viver ‚Äî e por qu√™.

## Vida transit√≥ria: sempre atual, nunca compartilhada

Um servi√ßo registrado como **Transient** √© criado **toda vez** que √© solicitado ao cont√™iner DI. Sem reutiliza√ß√£o. Sem cache. √â a forma mais limpa e isolada de instancia√ß√£o.

Isso o torna ideal para servi√ßos leves e sem estado ‚Äî como classes de utilit√°rios, validadores ou construtores ‚Äî que n√£o mant√™m nenhum dado compartilhado e n√£o dependem do gerenciamento do ciclo de vida.

**Exemplo de registro:**

```c#
builder.Services.AddTransient<IEmailSender, SmtpEmailSender>();
```

**O que acontece:**

- Cada ponto de inje√ß√£o recebe uma nova inst√¢ncia.
- Se injetado v√°rias vezes na mesma solicita√ß√£o, cada inje√ß√£o obt√©m sua pr√≥pria c√≥pia.

**Bons casos de uso:**

- Servi√ßos sem estado interno
- Opera√ß√µes sem estado, como formatadores, mapeadores ou construtores de solicita√ß√µes
- Opera√ß√µes de curta dura√ß√£o que n√£o necessitam de rastreamento de descarte

**Coisas a serem observadas:**

- Uso excessivo de servi√ßos transit√≥rios que s√£o caros de construir
- Esquecer de descartar manualmente se o servi√ßo contiver recursos n√£o gerenciados
- Injetando servi√ßos transit√≥rios em servi√ßos com escopo ou singleton com alta frequ√™ncia

Use Transient quando voc√™ n√£o se importa com reutiliza√ß√£o e s√≥ quer inst√¢ncias limpas e independentes.

## Tempo de vida com escopo: uma inst√¢ncia por solicita√ß√£o

Um servi√ßo **com escopo** √© criado uma vez por solicita√ß√£o (ou escopo) e reutilizado ao longo de toda a vida √∫til da solicita√ß√£o. Isso o torna perfeito para opera√ß√µes espec√≠ficas de solicita√ß√£o ‚Äî servi√ßos que precisam compartilhar contexto ou estado entre diferentes camadas da aplica√ß√£o, mas devem ser redefinidos assim que a solicita√ß√£o for encerrada.

**Exemplo de registro:**

```c#
builder.Services.AddScoped<IUserContext, HttpUserContext>();
```

**O que acontece:**

- Uma inst√¢ncia √© criada quando o escopo (geralmente a solicita√ß√£o HTTP) come√ßa.
- Essa mesma inst√¢ncia √© usada para cada inje√ß√£o dentro desse escopo.
- Uma nova inst√¢ncia √© criada para a pr√≥xima solicita√ß√£o.

**Bons casos de uso:**

- Servi√ßos que rastreiam ou dependem de dados espec√≠ficos da solicita√ß√£o (por exemplo, usu√°rio atual, ID de correla√ß√£o)
- DbContext no EF Core
- Camadas de cache vinculadas √† solicita√ß√£o

**Coisas a serem observadas:**

- Injetar servi√ßos com escopo em servi√ßos Singleton ‚Äî isso causa exce√ß√µes de tempo de execu√ß√£o
- Cria√ß√£o manual de escopos sem descart√°-los (vazamentos de mem√≥ria)
- Supondo que a mesma inst√¢ncia seja compartilhada entre as solicita√ß√µes ‚Äî n√£o √©

Scoped √© a escolha padr√£o para muitos servi√ßos em aplica√ß√µes web, especialmente ao trabalhar com APIs, autentica√ß√£o ou camadas de acesso a dados. Ele proporciona consist√™ncia em uma solicita√ß√£o sem vazamento acidental de dados para a pr√≥xima.

## Singleton Lifetime: Uma inst√¢ncia para o aplicativo

Um servi√ßo **Singleton** √© criado **uma vez** e compartilhado por todo o ciclo de vida do aplicativo. Ele √© registrado uma vez, constru√≠do uma vez e reutilizado para sempre.

Por ter uma vida √∫til t√£o longa, ele √© mais adequado para servi√ßos sem estado, seguros para threads e com pouca mem√≥ria, que n√£o dependem da solicita√ß√£o ou do contexto do usu√°rio.

**Exemplo de registro:**

```c#
builder.Services.AddSingleton<IClock, SystemClock>();
```

**O que acontece:**

- Uma inst√¢ncia √© criada na primeira vez que √© necess√°ria (ou na inicializa√ß√£o, se explicitamente constru√≠da).
- A mesma inst√¢ncia √© injetada em todos os lugares, em todas as solicita√ß√µes, em todos os threads.

**Bons casos de uso:**

- Provedores de configura√ß√£o
- Servi√ßos de cache
- Registro, servi√ßos de tempo e utilit√°rios de fonte √∫nica
- Trabalhadores em segundo plano e servi√ßos hospedados

**Coisas a serem observadas:**

- N√£o injete servi√ßos com escopo em Singletons ‚Äî isso travar√° em tempo de execu√ß√£o
- Tenha cuidado com o estado interno ‚Äî se ele for mut√°vel e acessado simultaneamente, voc√™ precisa lidar com a seguran√ßa do thread
- Evite depend√™ncias pesadas ou recursos descart√°veis, a menos que voc√™ esteja lidando com a limpeza adequadamente

Singletons oferecem desempenho e consist√™ncia, mas exigem disciplina. S√£o globais por natureza, portanto, qualquer estado ou depend√™ncia mal gerenciados pode ter impacto em todo o aplicativo. Use-os somente quando tiver certeza de que o servi√ßo √© seguro para ser compartilhado em todos os lugares, durante todo o ciclo de vida do aplicativo.

## Exemplos do mundo real: escolhendo o ciclo de vida certo

A escolha do tempo de vida correto depende de como o seu servi√ßo √© usado e do tipo de dados que ele cont√©m. Veja como os tempos de vida se comportam em aplica√ß√µes .NET reais:

**1. Servi√ßos de utilidade p√∫blica transit√≥rios e leves**

Exemplo: `IEmailBuilder`, `IPasswordHasher` Esses servi√ßos n√£o t√™m estado, s√£o baratos de criar e frequentemente injetados em v√°rios servi√ßos ou manipuladores. Uma nova inst√¢ncia por uso evita o compartilhamento acidental de estado.

```c#
builder.Services.AddTransient<IEmailBuilder, DefaultEmailBuilder>();
```

**Por que o Transient funciona:** N√£o h√° estado a ser preservado entre os usos. Compartilhar inst√¢ncias n√£o agrega valor e pode levar a efeitos colaterais acidentais se algu√©m adicionar estado posteriormente.

**2. Escopo ‚Äì Servi√ßos que rastreiam o contexto espec√≠fico da solicita√ß√£o**

Exemplo: `ICurrentUserService`, `ApplicationDbContext`, `IUnitOfWork` Esses servi√ßos est√£o vinculados ao ciclo de vida da solicita√ß√£o e geralmente dependem do contexto HTTP ou de dados com escopo.

```c#
builder.Services.AddScoped<ICurrentUserService, HttpContextUserService>();
builder.Services.AddScoped<ApplicationDbContext>();
```

**Por que o Scoped funciona:** Cada solicita√ß√£o recebe uma nova vers√£o. Os servi√ßos podem compartilhar com seguran√ßa o estado espec√≠fico da solicita√ß√£o sem vaz√°-lo entre elas.

**3. Singleton ‚Äì Infraestrutura global e sem estado**

Exemplo: `ILogger<T>`, `IClock`, `ICacheService`, `IConfigurationProvider` Esses servi√ßos encapsulam recursos globais do sistema ou fornecem l√≥gica compartilhada que n√£o depende do estado do usu√°rio ou da solicita√ß√£o.

```c#
builder.Services.AddSingleton<IClock, SystemClock>();
```

**Por que Singleton funciona:** A l√≥gica n√£o muda entre as solicita√ß√µes. O servi√ßo √© sem estado, thread-safe e barato de reutilizar.

Se um Singleton depender de um servi√ßo com escopo (como um logger gravando informa√ß√µes do usu√°rio), refatore. Passe apenas o necess√°rio (como o nome de usu√°rio) ou use `IServiceScopeFactory` para resolver servi√ßos com escopo corretamente dentro da l√≥gica Singleton.

Definir os tempos de vida corretamente significa entender a _propriedade_ dos dados. Quem precisa deles, por quanto tempo s√£o v√°lidos e onde devem ser isolados. Combine esse comportamento com o tempo de vida apropriado para evitar bugs e gargalos.

## Erros comuns com tempos de vida de servi√ßo (e como evit√°-los)

### **Injetando servi√ßos com escopo no Singleton**

Servi√ßos com escopo dependem de dados espec√≠ficos da solicita√ß√£o. Injet√°-los em Singletons quebra esse contrato e leva a erros de tempo de execu√ß√£o ou comportamento inesperado.

**Corre√ß√£o:** Use `IServiceScopeFactory` para resolver servi√ßos com escopo dentro de um escopo de n√≠vel de m√©todo, se for absolutamente necess√°rio.

### **Usando Singleton para servi√ßos mut√°veis ou inseguros para threads**

Servi√ßos singleton s√£o compartilhados entre todas as requisi√ß√µes e threads. Se eles mantiverem estado mut√°vel sem a devida seguran√ßa de threads, voc√™ estar√° convidando a condi√ß√µes de corrida.

**Corre√ß√£o:** Mantenha os singletons sem estado ou torne-os seguros para threads usando `ConcurrentDictionary`, `lock` ou outros mecanismos de sincroniza√ß√£o.

### **Uso excessivo de transientes para servi√ßos pesados ou descart√°veis**

Servi√ßos transit√≥rios s√£o criados sempre que s√£o injetados. Fazer isso para servi√ßos caros de construir ou descart√°veis pode degradar rapidamente o desempenho.

**Corre√ß√£o:** use Scoped ou Singleton para servi√ßos pesados ou com recursos limitados.

### **N√£o descartar servi√ßos transit√≥rios resolvido manualmente**

O cont√™iner descarta servi√ßos somente se controlar seu ciclo de vida. Se voc√™ resolver manualmente um Transient sem descart√°-lo, haver√° vazamento de mem√≥ria.

**Corre√ß√£o:** Evite resolu√ß√£o manual sempre que poss√≠vel. Se necess√°rio, garanta o descarte adequado usando blocos `using` ou `Dispose()`.

### **Supondo que o escopo funcione automaticamente fora de solicita√ß√µes HTTP**

Em servi√ßos em segundo plano, servi√ßos hospedados ou aplicativos de console, n√£o h√° solicita√ß√£o HTTP, portanto, n√£o h√° escopo padr√£o.

**Corre√ß√£o:** Crie escopos manualmente usando `IServiceScopeFactory.CreateScope()` ao trabalhar fora de pipelines HTTP.

Essas s√£o armadilhas que pegam at√© desenvolvedores experientes. Acerte o tempo de vida √∫til do seu servi√ßo e seu aplicativo permanecer√° r√°pido, limpo e est√°vel. Se errar, voc√™ ter√° bugs dif√≠ceis de reproduzir e abstra√ß√µes com vazamentos.

## Como o .NET gerencia internamente os tempos de vida dos servi√ßos

O cont√™iner DI integrado ao .NET (Microsoft.Extensions.DependencyInjection) √© um sistema simples, por√©m poderoso. Ele gerencia o tempo de vida dos objetos usando uma combina√ß√£o de descritores de servi√ßo e rastreamento de escopo.

Veja o que acontece nos bastidores:

**1. Registro de Servi√ßo** Cada vez que voc√™ chama `AddTransient`, `AddScoped` ou `AddSingleton`, voc√™ est√° registrando um `ServiceDescriptor` na `IServiceCollection`. Este descritor cont√©m:

- O tipo de servi√ßo
- O tipo de implementa√ß√£o ou f√°brica
- O tempo de vida especificado

Esses descritores s√£o usados para construir um `ServiceProvider`.

**2. Resolvendo Servi√ßos** Quando o aplicativo √© iniciado, `ServiceProvider` √© criado a partir de `IServiceCollection`. Este provedor √© respons√°vel por criar e gerenciar inst√¢ncias de servi√ßo.

- **Singleton**: Armazenado em cache em um dicion√°rio de n√≠vel raiz. Instanciado uma vez e reutilizado em todos os escopos.
- **Escopo**: Cada escopo (`IServiceScope`) possui seu pr√≥prio cache para servi√ßos com escopo. Durante a resolu√ß√£o, ele verifica o cache local antes de criar uma nova inst√¢ncia.
- **Transiente**: Sem cache. Uma nova inst√¢ncia √© sempre criada invocando o construtor ou a f√°brica.

**3. Gerenciamento de Escopo** Um escopo √© criado por solicita√ß√£o no ASP.NET Core. Middlewares como `UseRouting()` e `UseEndpoints()` garantem que `IServiceScope` seja criado no in√≠cio de cada solicita√ß√£o HTTP e descartado no final.

Ao injetar `IServiceScopeFactory` e criar um escopo manualmente, voc√™ est√° imitando esse comportamento fora do pipeline HTTP.

**4. Descarte de Servi√ßos** O cont√™iner rastreia implementa√ß√µes `IDisposable`:

- **Singletons** s√£o descartados quando o `ServiceProvider` raiz √© descartado (geralmente no desligamento do aplicativo).
- Os servi√ßos **com escopo** s√£o descartados quando o escopo termina (normalmente no final de uma solicita√ß√£o).
- Os servi√ßos **transit√≥rios** s√£o descartados _somente_ se o cont√™iner os criou e possui o seu ciclo de vida.

Se voc√™ instanciar manualmente um servi√ßo usando `GetRequiredService()` dentro de um escopo personalizado ou fora do sistema DI, voc√™ ser√° respons√°vel pelo descarte.

**5. Seguran√ßa de Threads** O cont√™iner DI padr√£o √© seguro para threads em registros e resolu√ß√µes. Mas ele n√£o imp√µe seguran√ßa de threads em seus servi√ßos. Se voc√™ armazenar o estado em um Singleton, voc√™ ter√° que sincronizar o acesso por conta pr√≥pria.

O .NET mant√©m este sistema r√°pido e leve por:

- Evitando reflex√£o em tempo de execu√ß√£o ap√≥s a compila√ß√£o
- Pr√©-computa√ß√£o de sites de chamada de construtor
- Usando pool de objetos quando aplic√°vel (como `DbContext` no EF Core)

Entender esse fluxo interno ajuda a depurar problemas como "por que meu servi√ßo foi descartado antecipadamente?" ou "por que estou recebendo a mesma inst√¢ncia quando esperava uma nova?". Tamb√©m ajuda a decidir quando voc√™ precisa de cont√™ineres mais avan√ßados ‚Äî embora, na maioria dos casos, o sistema DI integrado seja mais do que suficiente.

## Melhores pr√°ticas para projetar servi√ßos com reconhecimento de vida √∫til

### Mantenha Singletons sem estado e thread-safe

Singletons s√£o reutilizados em todas as requisi√ß√µes e threads. Se mantiverem o estado interno, certifique-se de que o estado seja imut√°vel ou protegido com sincroniza√ß√£o adequada. Prefira um design sem estado para evitar condi√ß√µes de corrida e problemas de compartilhamento de dados.

### Evite depend√™ncias com escopo em singletons

Injetar um servi√ßo com escopo em um singleton gerar√° um erro de tempo de execu√ß√£o. Se um singleton precisar absolutamente de dados de um servi√ßo com escopo, resolva-o dentro de um m√©todo usando `IServiceScopeFactory` e descarte o escopo corretamente.

```c#
using var scope = _scopeFactory.CreateScope();
var scopedService = scope.ServiceProvider.GetRequiredService<IMyScopedService>();
```

### Preferencialmente com escopo para servi√ßos de aplica√ß√£o

A maioria dos servi√ßos que lidam com l√≥gica espec√≠fica de solicita√ß√£o ‚Äî como `DbContext`, `IUserContext` ou `IUnitOfWork` ‚Äî deve ter escopo definido. Isso garante limites claros entre as solicita√ß√µes e evita estados compartilhados.

### Use Transient para servi√ßos sem estado e de baixo custo

Transient √© √≥timo para servi√ßos pequenos e reutiliz√°veis, como mapeadores, validadores ou formatadores. Se o servi√ßo n√£o tiver estado e for barato de criar, o Transient mant√©m as coisas simples e seguras.

### Seja expl√≠cito com servi√ßos descart√°veis

Se o seu servi√ßo implementar `IDisposable`, esteja ciente de quem √© o propriet√°rio do seu ciclo de vida. Se ele for resolvido manualmente ou usado fora do escopo do cont√™iner, voc√™ ser√° respons√°vel por descart√°-lo.

### Associe a vida √∫til ao comportamento, n√£o apenas ao desempenho

N√£o escolha Singleton s√≥ porque √© ‚Äúmais r√°pido‚Äù. Associe o tempo de vida √† responsabilidade:

- Depende da solicita√ß√£o? Use Scoped.
- Precisa de uma tela limpa sempre? Use Transient.
- √â sem estado e compartilhado globalmente? Use Singleton.

### Crie interfaces personalizadas para limites de ciclo de vida

Divida as responsabilidades de servi√ßo entre interfaces com diferentes tempos de vida. Por exemplo, um servi√ßo em segundo plano Singleton pode depender de uma interface leve que resolve internamente os servi√ßos com escopo por opera√ß√£o.

```c#
public interface IScopedProcessor
{
    Task ProcessAsync(CancellationToken cancellationToken);
}
```

Dessa forma, os tempos de vida permanecem isolados e alinhados com o contexto do tempo de execu√ß√£o.

## Resumo

Acertar o tempo de vida dos servi√ßos n√£o √© negoci√°vel em aplicativos .NET. Transient, Scoped e Singleton t√™m fun√ß√µes espec√≠ficas, e us√°-los incorretamente pode levar a vazamentos de mem√≥ria, problemas de threading e comportamento inst√°vel.

- Use **Transient** para servi√ßos sem estado, leves e descart√°veis
- Use **Scoped** para qualquer coisa vinculada a uma solicita√ß√£o ou opera√ß√£o l√≥gica
- Use **Singleton** apenas para servi√ßos globais, sem estado e thread-safe

Sempre projete seus servi√ßos com o contexto em mente. Preste aten√ß√£o ao que eles dependem, por quanto tempo essa depend√™ncia deve existir e como o cont√™iner DI a gerenciar√°. Um gerenciamento limpo do tempo de vida leva a melhor desempenho, c√≥digo mais seguro e depura√ß√£o mais f√°cil.

Tem alguma ideia, pergunta ou feedback? Adoraria saber o que te fez trope√ßar ao aprender sobre vidas ‚Äî ou quais padr√µes voc√™ est√° usando em seus pr√≥prios projetos. Deixe um coment√°rio ou mensagem direta a qualquer momento üòä

Al√©m disso, se voc√™ leva a s√©rio o dom√≠nio do .NET, confira o curso **.NET Web API Zero to Hero** ‚Äî ele √© totalmente **GRATUITO** e abrange tudo, desde os fundamentos at√© a arquitetura pronta para produ√ß√£o.

üëâ [Participe do meu curso .NET Web API Zero to Hero](https://codewithmukesh.com/courses/dotnet-webapi-zero-to-hero/#join-now)

---
