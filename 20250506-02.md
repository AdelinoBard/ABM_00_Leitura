- **Cita√ß√£o**
  - **T√≠tulo**: Going beyond singleton, scoped, and transient lifetimes‚Äîtenant, pooled, and drifter
  - **Autor**: Andrew Lock
  - **Fonte**: Andrew Lock | .NET Escapades
  - **URL**: https://andrewlock.net/going-beyond-singleton-scoped-and-transient-lifetimes/
  - **Atualizado**: 22 de abril de 2025

---

# Indo al√©m dos tempos de vida singleton, scoped e transient ‚Äî tenant, pooled e drifter

Este √© o primeiro de dois posts e √©, em grande parte, resultado de uma s√©rie de cr√≠ticas nerds enquanto ouvia um epis√≥dio do [The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/) que discutia inje√ß√£o de depend√™ncia (DI) e os poss√≠veis tempos de vida de servi√ßo dispon√≠veis. Em v√°rios momentos, Khalid, Maarten e Woody discutiram hipot√©ticos tempos de vida "adicionais". Isso me fez pensar em qu√£o vi√°vel seria criar vers√µes pr√°ticas desses tempos de vida.

Neste post, descrevo brevemente os tempos de vida padr√£o dispon√≠veis no cont√™iner .NET DI. Em seguida, descrevo brevemente os tr√™s tempos de vida hipot√©ticos descritos no podcast. Por fim, mostro como voc√™ pode implementar um desses tempos de vida na pr√°tica. No pr√≥ximo post, mostro uma poss√≠vel implementa√ß√£o para o tempo de vida restante.

## [Vida √∫til do servi√ßo dispon√≠vel no cont√™iner .NET Core DI](#service-lifetimes-available-in-the-net-core-di-container)

Antes de analisarmos esses escopos de servi√ßo hipot√©ticos adicionais, vamos garantir que entendemos os escopos de tempo de vida _existentes_ que est√£o dispon√≠veis no .NET Core.

> Este post n√£o pretende ser uma introdu√ß√£o completa √† inje√ß√£o de depend√™ncia no .NET Core. Se voc√™ quiser saber mais, a documenta√ß√£o da Microsoft cont√©m [uma introdu√ß√£o √† inje√ß√£o de depend√™ncia](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection). Como alternativa, os [cap√≠tulos 8](https://livebook.manning.com/book/asp-net-core-in-action-third-edition/chapter-8/) [e 9](https://livebook.manning.com/book/asp-net-core-in-action-third-edition/chapter-9/) do meu livro cont√™m uma introdu√ß√£o mais longa √† inje√ß√£o de depend√™ncia em geral, bem como aos tempos de vida padr√£o de DI.

Ao registrar servi√ßos no cont√™iner .NET Core DI, voc√™ escolhe um dos tr√™s diferentes tempos de vida.

- Singleton
- Scoped
- Transient

O tempo de vida especificado controla como e quando o cont√™iner DI escolhe criar uma nova inst√¢ncia de um determinado servi√ßo e quando ele retorna uma inst√¢ncia j√° existente do servi√ßo.

### [Servi√ßos Singleton](#singleton-services)

Singleton √© o tempo de vida mais simples que voc√™ pode dar a um servi√ßo. Servi√ßos singleton s√£o criados apenas uma vez. Ao registrar um servi√ßo como singleton, voc√™ pode fornecer explicitamente a inst√¢ncia que o cont√™iner DI deve sempre retornar ou pode instruir o cont√™iner DI a criar uma inst√¢ncia, mas sempre reutiliz√°-la.

```c#
var builder = WebApplication.CreateBuilder(args);

// Providing an explicit instance of SingletonClass1 to use
builder.Services.AddSingleton(new SingletonClass1());

// Or, allowing the DI container to create the SingletonClass2
builder.Services.AddSingleton<SingletonClass2>();

// Or, providing a "factory function" for the the container to use to create the instance
builder.Services.AddSingleton(serviceProvider => new SingletonClass3());
```

No primeiro m√©todo de registro acima, a inst√¢ncia de `SingletonClass1` √© explicitamente fornecida ao cont√™iner DI. O cont√™iner ent√£o usa essa inst√¢ncia sempre que precisa de uma inst√¢ncia do tipo e n√£o cria uma nova vers√£o.

No segundo m√©todo de registro mostrado acima, o cont√™iner DI √© respons√°vel por criar a inst√¢ncia de `SingletonClass2`. Na primeira vez que `SingletonClass2` √© solicitado, o cont√™iner DI cria uma inst√¢ncia. Em seguida, ele reutiliza a mesma inst√¢ncia sempre que precisa de uma inst√¢ncia do tipo.

O m√©todo final mostrado acima funciona praticamente da mesma forma que o segundo m√©todo, a √∫nica diferen√ßa √© que voc√™ est√° fornecendo um m√©todo lambda "de f√°brica" expl√≠cito que o cont√™iner invoca para criar uma inst√¢ncia de `SingletonClass3`.

O ponto principal √© que, em todos os casos, o cont√™iner cria no m√°ximo uma √∫nica inst√¢ncia, e essa mesma inst√¢ncia √© usada para atender a quaisquer solicita√ß√µes do tipo.

### [Servi√ßos com escopo](#scoped-services)

Servi√ßos com escopo s√£o, sem d√∫vida, os mais confusos entre os tempos de vida de servi√ßo. Isso se deve principalmente √† introdu√ß√£o de um novo conceito: escopo. Acredito que a maneira mais f√°cil de entender o conceito de escopo √© v√™-lo em a√ß√£o:

```c#
var builder = WebApplication.CreateBuilder(args);

// Allowing the DI container to create the ScopedClass
builder.Services.AddScoped<ScopedClass>();

// Alternatively, providing a "factory function" for the the container to use to create the instance
builder.Services.AddScoped(serviceProvider => new ScopedClass2());

var app = builder.Build();

// Hold a reference to the object _outside_ of the scope, for demo purposes only
// WARNING: you shouldn't do this normally, as the service is disposed when the scope ends
ScopedClass service;

// create a scope
using (var scope = app.Services.CreateScope())
{
    // Retreive the first instance
    service = scope.ServiceProvider.GetRequiredService<ScopedClass>();

    // Request another instance of the ScopedClass
    var other = scope.ServiceProvider.GetRequiredService<ScopedClass>();

    // The DI container returns the same instance in both cases
    Console.WriteLine(service == other); // true
}

using (var scope = app.Services.CreateScope())
{
    // In a different  scope, the DI container returns a _different_ instance
    var other = scope.ServiceProvider.GetRequiredService<ScopedClass>();
    Console.WriteLine(service == other); // false
}
```

O ponto principal √© que, _dentro_ de um escopo, o cont√™iner DI retorna a _mesma_ inst√¢ncia de `ScopedClass` sempre que solicitado. Mas para escopos _diferentes_, o cont√™iner DI retorna uma inst√¢ncia _diferente_ de `ScopedClass`.

No c√≥digo acima, criei explicitamente o escopo, mas se voc√™ estiver usando o ASP.NET Core, o escopo normalmente √© criado automaticamente pelo framework e dura apenas uma √∫nica solicita√ß√£o. Isso significa que todos os usos do servi√ßo `ScopedClass` com escopo definido _dentro de uma determinada solicita√ß√£o_ retornam a mesma inst√¢ncia de uma `ScopedClass`, mas voc√™ obt√©m uma inst√¢ncia _diferente_ de `ScopedClass` quando est√° em solicita√ß√µes _diferentes_.

### [Servi√ßos transit√≥rios](#transient-services)

Os servi√ßos transit√≥rios s√£o relativamente simples: cada solicita√ß√£o de um servi√ßo transit√≥rio retorna uma nova inst√¢ncia.

```c#
var builder = WebApplication.CreateBuilder(args);

// Allowing the DI container to create the TransientClass
builder.Services.AddTransient<TransientClass>();

// Alternatively, providing a "factory function" for the the container to use to create the instance
builder.Services.AddTransient(serviceProvider => new TransientClass2());

var app = builder.Build();

// create a scope
using (var scope = app.Services.CreateScope())
{
    // Request the first instance
    var service = scope.ServiceProvider.GetRequiredService<TransientClass>();

    // Request another instance of the TransientClass
    var other = scope.ServiceProvider.GetRequiredService<TransientClass>();

    // Even inside the same scope, the instances are different
    Console.WriteLine(service == other); // false
}
```

Toda vez que voc√™ solicita uma inst√¢ncia de `TransientService`, mesmo que esteja na mesma solicita√ß√£o, o cont√™iner DI cria uma nova inst√¢ncia da classe `TransientService`.

Isso abrange os escopos padr√£o suportados pelas bibliotecas _Microsoft.Extensions.DependencyInjection_ usadas pelo ASP.NET Core. Na pr√≥xima se√ß√£o, descrevo alguns dos escopos "hipot√©ticos" que foram discutidos no [The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/).

## [Escopos de tempo de vida adicionais do Breakpoint Show](#the-breakpoint-show-s-additional-lifetime-scopes)

No [epis√≥dio 36 do The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/), Khalid, Maarten e Woody discutem as tr√™s vidas que descrevi acima, fornecendo alguns exemplos de quando voc√™ pode escolher cada uma delas, problemas a serem observados e outras coisas a serem consideradas.

Ao longo do programa, eles tamb√©m discutiram o desejo por tr√™s tipos "adicionais" de servi√ßos, que n√£o se encaixavam perfeitamente nos tempos de vida padr√£o:

- Servi√ßos com escopo de locat√°rio (Tenant-scoped services)
- Servi√ßos agrupados (Pooled services)
- Servi√ßos baseados em tempo (drifter) (Time-based (drifter) services)

Nas se√ß√µes a seguir, forne√ßo uma breve vis√£o geral de alto n√≠vel desses escopos te√≥ricos.

### [Servi√ßos com escopo de locat√°rio](#tenant-scoped-services)

Servi√ßos com escopo de locat√°rio foram mencionados por Maarten como um exemplo pr√°tico existente, que ele utilizou em aplica√ß√µes multilocat√°rias reais. Eles s√£o √∫teis quando voc√™ deseja que alguns servi√ßos sejam "singletons", mas n√£o deseja que eles sejam compartilhados por toda a aplica√ß√£o. Em vez disso, voc√™ deseja que eles sejam "singletons para um determinado locat√°rio".

Como voc√™ pode imaginar, aplicativos multilocat√°rios s√£o relativamente comuns, portanto, existem v√°rios pacotes que voc√™ pode usar para ajudar a configurar servi√ßos singleton em seu aplicativo. Escrevi sobre o SaasKit [em 2016](https://andrewlock.net/tag/multi-tenancy/), mas esse pacote n√£o recebeu muitas atualiza√ß√µes desde ent√£o, e agora existem algumas [alternativas modernas](https://www.nuget.org/packages?q=multitenant).

Uma dessas alternativas √© explicada por Michael McKenna [em sua s√©rie de blogs](https://michael-mckenna.com/multi-tenant-asp-dot-net-8-tenant-resolution/). Em particular, [ele descreve como voc√™ pode criar servi√ßos com "escopo de locat√°rio"](https://michael-mckenna.com/multi-tenant-asp-dot-net-8-tenant-services/) criando um novo cont√™iner "raiz com escopo de locat√°rio" quando uma solicita√ß√£o chega em um aplicativo ASP.NET Core, o que garante que os servi√ßos de cada locat√°rio sejam isolados uns dos outros. N√£o descreverei a abordagem com mais detalhes aqui, pois Michael explica muito bem como ela funciona em seu blog.

### [Servi√ßos agrupados](#pooled-services)

Servi√ßos agrupados foram mencionados por Woody como uma forma de reduzir aloca√ß√µes em sua aplica√ß√£o para melhorar o desempenho. A ideia foi inspirada no recurso de agrupamento `DbContext` do EF Core, que pode ser √∫til em alguns cen√°rios de alto desempenho. O benchmark de desempenho de thread √∫nica, que compara o agrupamento `DbContext` com o n√£o agrupamento, mostra que ele pode fazer uma diferen√ßa significativa em alguns casos:

| M√©todo | NumBlogs | M√©dia | Erro | DesvioPadr√£o | Gera√ß√£o 0 | Gera√ß√£o 1 | Gera√ß√£o 2 | Alocado |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| SemContextPooling | 1 | 701,6 n√≥s | 26,62 n√≥s | 78,48 n√≥s | 11,7188 | - | - | 50,38 KB |
| WithContextPooling | 1 | 350,1 n√≥s | 6,80 n√≥s | 14,64 n√≥s | 0,9766 | - | - | 4,63 KB |

Esses n√∫meros parecem √≥timos, e quanto mais r√°pido, melhor, certo? Mas vale a pena estar ciente de que voc√™ nem sempre ver√° essas melhorias no pooling. Sempre que voc√™ retorna um objeto agrupado ao pool, ele precisa "redefinir" seu estado, para que seja seguro reutiliz√°-lo em outra solicita√ß√£o. Em alguns casos, o tempo gasto redefinindo um objeto pode superar a economia obtida por n√£o alocar um novo objeto. Existem tamb√©m outras armadilhas potenciais sutis.

No entanto, ter suporte "nativo" para usar pooling no cont√™iner DI √© uma ideia interessante, ent√£o mostrarei uma abordagem para implementar isso no meu pr√≥ximo post.

### [Servi√ßos baseados em tempo (drifter)](#time-based-drifter-services)

A vida final foi descrita por Khalid como a vida do "vagabundo". Ele a descreveu como algo entre uma vida com escopo e uma vida transit√≥ria ‚Äî ela fica na cidade por um curto per√≠odo antes de partir.

Mais concretamente, pensei nele como um servi√ßo baseado em tempo, pois essencialmente "vive" por um per√≠odo fixo. Por um per√≠odo espec√≠fico (at√© o tempo limite expirar), sempre que voc√™ solicita uma inst√¢ncia deste servi√ßo, voc√™ recebe o mesmo item, ent√£o ele se comporta um pouco como um servi√ßo com escopo. No entanto, quando o tempo limite √© excedido, voc√™ recebe uma nova inst√¢ncia do tipo.

> Tenho dificuldade em pensar em um bom exemplo de quando voc√™ gostaria de fazer isso na pr√°tica. Parece um pouco com um cache, onde voc√™ quer "atualizar" os dados (obtendo uma nova inst√¢ncia) ap√≥s um determinado per√≠odo de tempo. Mas eu provavelmente implementaria isso como um tipo singleton, onde os dados s√£o atualizados em uma thread em segundo plano. ü§∑ ‚Äç ‚ôÇ Ô∏è

S√≥ por divers√£o, imaginei como seria expor esse tempo de vida baseado em tempo como um conceito no cont√™iner .NET DI. Acontece que criar uma implementa√ß√£o ing√™nua √© bem f√°cil, mas h√° uma s√©rie de sutilezas para tornar algo pr√°tico e seguro!

## [Implementando um servi√ßo de tempo de vida simples baseado em tempo](#implementing-a-simple-time-based-lifetime-service)

Para reiterar, decidi que um servi√ßo vital√≠cio √∫til baseado em tempo deveria ter as seguintes caracter√≠sticas:

- Todas as solicita√ß√µes dentro de um determinado escopo devem usar a mesma inst√¢ncia do servi√ßo (para que ele se comporte de forma semelhante a um servi√ßo de tempo de vida com escopo).
- Ap√≥s o tempo limite do servi√ßo expirar, uma nova inst√¢ncia do tipo dever√° ser criada quando solicitada.

O resultado l√≠quido √© que inst√¢ncias de servi√ßos de tempo de vida baseados em tempo podem ou n√£o ser reutilizadas em todas as solicita√ß√µes.

### [Implementando `TimedDependencyFactory<T>`](#implementing-timeddependencyfactoryt)

Para implementar o tempo de vida, usei um padr√£o de f√°brica. A f√°brica √© respons√°vel por criar novas inst√¢ncias da depend√™ncia, mas tamb√©m por armazenar em cache a inst√¢ncia atual pelo tempo de vida definido.

> A implementa√ß√£o ing√™nua da f√°brica √© muito simples, mas para tornar o thread da f√°brica seguro e garantir que n√£o criemos mais de uma inst√¢ncia da depend√™ncia por vez, podemos usar algumas abordagens interessantes.

Outro ponto a ser observado √© que optei por usar [a abstra√ß√£o `TimeProvider`](/exploring-the-dotnet-8-preview-avoiding-flaky-tests-with-timeprovider-and-itimer/) introduzida no .NET 8, que permite testar o comportamento da f√°brica, evitando testes inst√°veis. A f√°brica √© mostrada abaixo e possui anota√ß√µes detalhadas para explicar seu comportamento.

```c#
private class TimedDependencyFactory<T>
{
    // TimeProvider can get the current time, but is also testable
    private readonly TimeProvider _time;
    // How long should the dependency be kept around
    private readonly TimeSpan _lifetime;
    // A factory function for creating a new instance
    private readonly Func<T> _factory;

    // The current cached instance, as a pair of Lazy<T> and the time the instance is valid till
    // We can't use a ValueTuple here, because we need reference semantics later
    private Tuple<Lazy<T>, DateTimeOffset>? _instance;

    public TimedDependencyFactory(TimeProvider time, TimeSpan lifetime, IServiceProvider serviceProvider)
    {
        _lifetime = lifetime;
        // ActivatorUtilities will pull any dependencies in the T constructor
        // from the IServiceProvider. Only Singleton or Transient dependencies
        // make sense for injecting into the timed-dependency T
        _factory = () => ActivatorUtilities.CreateInstance<T>(serviceProvider);
        _time = time;
    }

    /// <summary>
    /// Gets or creates an instance of <typeparamref name="T" />
    /// </summary>
    public T GetInstance()
    {
        // Store the current instance in a local variable
        var instance = _instance;
        // Fetch the current time using the time provider
        var now = _time.GetUtcNow();
        if (instance is not null && now < instance.Item2)
        {
            // The current item is still valid, so return it
            return instance.Item1.Value;
        }

        // We either don't have an instance yet, or the existing one
        // has expired, so create a new instance of the Lazy,
        //  and calculate the expiry date
        var newInstance = new Tuple<Lazy<T>, DateTimeOffset>(
            new Lazy<T>(_factory),
            now.Add(_lifetime));

        // Atomically replace the previous instance with the new one.
        // To make this thread safe, we use CompareExchange, which returns
        // the original value found in _instance.
        var previous = Interlocked.CompareExchange(
            ref _instance,
            newInstance,
            instance);

        // We compare the value that was stored in previous with
        // the instance we originally fetched, to check whether
        // a different thread beat us to the update
        if (ReferenceEquals(previous, instance))
        {
            // We replaced the value we expected, so return
            // our new instance by executing the Lazy<T>
            return newInstance.Item1.Value;
        }

        // A different thread replaced the current instance _before_ we did
        // so discard our current instance and try again. We could use the
        // previous value directly, and assume it's valid, but it's easier/safer
        // to simply recurrsively call this method again. Unless we have tiny
        // lifetimes, we don't expect more than one iteration here.
        return GetInstance();
    }
}
```

A parte mais interessante do c√≥digo acima √© o esfor√ßo necess√°rio para torn√°-lo thread-safe. Em termos gerais, isso √© alcan√ßado por

- Copiando o campo `_instance` para um valor `instance` local.
- Usando `Interlocked.CompareExchange()` para trocar atomicamente um novo valor. Isso garante que, se uma thread diferente estiver competindo com a nossa, e ambas criarem uma nova inst√¢ncia do valor armazenado, ambas as threads ser√£o consistentes sobre qual inst√¢ncia usar√£o.
- Usando `Lazy<T>` com uma f√°brica em vez de `T` para garantir que n√£o criemos mais de uma inst√¢ncia da depend√™ncia real `T` por vez.

Ainda n√£o testei completamente isso para verificar problemas de simultaneidade, mas _acho_ que resolve o problema. Avise-me nos coment√°rios se encontrar algum problema!

### [Usando uma implementa√ß√£o alternativa baseada em `Lock`](#using-an-alternative-lock-based-implementation)

Usei a abordagem `Lazy<T>` na se√ß√£o anterior, pois ela fornece uma abordagem interessante sem bloqueios\*, semelhante √† [abordagem que o ASP.NET Core usa com `ConcurrentDictionary.GetOrAdd()`](/making-getoradd-on-concurrentdictionary-thread-safe-using-lazy/) para evitar a cria√ß√£o de m√∫ltiplas inst√¢ncias da depend√™ncia `T`.

> \*Isso √© uma mentira, porque o `Lazy<T>` usa bloqueio nos bastidores üôà

No entanto, como n√£o medi as caracter√≠sticas de desempenho, pular direto para a abordagem `Lazy<T>` acima provavelmente √© um exagero. Uma vers√£o mais simples, que simplesmente use `lock(_lock)`, √© mais f√°cil de entender e pode, na verdade, ter um desempenho melhor em muitas circunst√¢ncias. Provavelmente precisar√≠amos medir nossa aplica√ß√£o real para entender como as caracter√≠sticas de cada abordagem impactam o desempenho.

O c√≥digo a seguir mostra como a implementa√ß√£o poderia mudar para usar `lock()`. Destaquei as diferen√ßas nessa implementa√ß√£o com coment√°rios.

```c#
private class TimedDependencyFactory<T>
{
    private readonly TimeProvider _time;
    private readonly TimeSpan _lifetime;
    private readonly Func<T> _factory;
    private readonly Lock _lock = new();
    // The _instance no longer needs to use Lazy<T>, just a T
    private Tuple<T, DateTimeOffset>? _instance;

    public TimedDependencyFactory(TimeProvider time, TimeSpan lifetime, IServiceProvider serviceProvider)
    {
        _lifetime = lifetime;
        _factory = () => ActivatorUtilities.CreateInstance<T>(serviceProvider);
        _time = time;
    }

    public T GetInstance()
    {
        var instance = _instance;
        var now = _time.GetUtcNow();
        if (instance is null || now > instance.Item2)
        {
            // The current value isn't valid, so create a new one
            // using a _lock_ here ensures that no other thread will change this value
            lock (_lock)
            {
                // Check that another thread didn't just create a new instance
                // before we entered the lock. If it did, then the new instance
                // should be valid.
                instance = _instance;
                if (instance is null || now > instance.Item2)
                {
                    // Create a new tuple, invoking the factory,
                    // and calculate the expiry date
                    instance = new Tuple<T, DateTimeOffset>(
                        _factory(), now.Add(_lifetime));
                    _instance = instance;
                }
            }
        }

        return instance.Item1;
    }
}
```

A implementa√ß√£o de `GetInstance()` neste caso √© muito mais simples. Simplesmente verificamos se a inst√¢ncia √© v√°lida. Caso contr√°rio, pegamos um `lock` e criamos uma nova em vez de usar um `Lazy<T>`.

### [Criando os m√©todos de extens√£o `AddTimed<>`](#creating-the-addtimed-extension-methods)

Agora que temos uma f√°brica (qualquer que seja a nossa escolha), podemos us√°-la para configurar nosso cont√™iner DI. Primeiro, criaremos um m√©todo de extens√£o auxiliar que recebe um par√¢metro de tipo, `T`, e um `TimeSpan` que indica o tempo de vida m√≠nimo da depend√™ncia:

```c#
public static class TimedScopeExtensions
{
    public static IServiceCollection AddTimed<T>(this IServiceCollection services, TimeSpan lifetime)
        where T : class
    {
        // Add the factory as a singleton, using the system TimeProvider implementation
        services.AddSingleton(provider => new TimedDependencyFactory<T>(
            TimeProvider.System, lifetime, provider));

        // Add the service itself as a dependency, delegating to the factory
        services.AddScoped(provider => provider
            .GetRequiredService<TimedDependencyFactory<T>>()
            .GetInstance());

        return services;
    }
}
```

Ao usar `AddScoped` para a depend√™ncia na extens√£o acima, garantimos que sempre usaremos a mesma inst√¢ncia durante a solicita√ß√£o. Lembre-se, por√©m, de que isso significa que estamos especificando o tempo de vida _m√≠nimo_ da depend√™ncia. Verificamos se a depend√™ncia ainda √© v√°lida quando √© solicitada pela primeira vez em uma solicita√ß√£o e se ela permanece v√°lida durante toda a solicita√ß√£o, mesmo que o tempo decorrido.

### [Testando as depend√™ncias temporizadas](#testing-out-the-timed-dependencies)

Agora que temos nossa implementa√ß√£o, podemos test√°-la. Criei uma aplica√ß√£o ASP.NET Core simples com um endpoint que depende de `TimedService`. Cada inst√¢ncia deste servi√ßo recebe um ID exclusivo, e simplesmente retornamos o ID do endpoint.

```c#
var builder = WebApplication.CreateBuilder(args);

// Add our service with a 5s lifetime
builder.Services.AddTimed<TimedService>(lifetime: TimeSpan.FromSeconds(5));

var app = builder.Build();
app.MapGet("/", (TimedService service) => service.GetValue);
app.Run();

public class TimedService
{
    private static int _id = 0;
    // Each new instance of TimedService gets a new value
    public int GetValue { get; } = Interlocked.Increment(ref _id);
}
```

Clicar no ponto final `/` retorna o valor `1` para todas as requisi√ß√µes por 5s, ap√≥s o qual retorna `2` e assim por diante. Funciona!

> Este teste n√£o demonstra que todas as inst√¢ncias de `TimedService` _dentro_ de uma solicita√ß√£o s√£o a mesma inst√¢ncia, ent√£o voc√™ ter√° que confiar em mim!

Como mencionei antes, n√£o tenho certeza de quais seriam os casos de uso aqui ‚Äî ele se comporta um pouco como um cache, mas n√£o exatamente. Mesmo assim, consigo pensar em algumas limita√ß√µes...

### [Limita√ß√µes da implementa√ß√£o do servi√ßo baseado em tempo](#limitations-of-the-time-based-service-implementation)

Um problema potencialmente significativo √© que a implementa√ß√£o mostrada nesta postagem n√£o lida com o caso em que `T` √© um `IDisposable`.

Este √©, na verdade, um problema interessante e surpreendentemente dif√≠cil de resolver. O problema √© que o cont√™iner DI chama automaticamente `Dispose` em qualquer inst√¢ncia `IDisposable` que ele retorna quando um escopo termina. Isso √© um problema para n√≥s, porque n√£o _queremos_ descartar a depend√™ncia at√© _depois_ de substitu√≠-la.

> Passei bastante tempo tentando resolver esse problema, adicionando camadas de objetos de "arrendamento" e v√°rias abordagens, mas em todos os casos n√£o consegui me livrar das potenciais condi√ß√µes de corrida. No final, percebi que estava gastando tempo demais nisso e desisti üòÖ

Outro ponto a considerar √© que ainda podemos ter _v√°rias_ inst√¢ncias de um servi√ßo `T` ativas ao mesmo tempo. Fiz um esfor√ßo para evitar a cria√ß√£o de m√∫ltiplas inst√¢ncias quando o tempo limite expira e voc√™ cria uma inst√¢ncia de substitui√ß√£o, usando `Lazy<T>` ou `lock()`. No entanto, isso _n√£o_ significa que haja apenas uma inst√¢ncia "ativa" do servi√ßo.

Por exemplo, uma solicita√ß√£o lenta pode estar usando a inst√¢ncia A, durante a qual o tempo limite expira. Uma segunda solicita√ß√£o √© recebida e, como o tempo limite expirou, a f√°brica cria uma nova inst√¢ncia, a inst√¢ncia B. Enquanto a solicita√ß√£o original est√° em execu√ß√£o, ambas as inst√¢ncias A e B est√£o em uso ativo.

![Demonstrando o problema de que v√°rias inst√¢ncias podem estar ativas ao mesmo tempo](./imagens/multiple_instances2.svg)

Se essas quest√µes n√£o forem um problema para voc√™, ent√£o voc√™ _deve_ conseguir usar a implementa√ß√£o acima, mas como n√£o tenho muito conhecimento sobre casos de uso na vida real, n√£o tenho certeza se essas limita√ß√µes provavelmente ser√£o um problema ou n√£o!

## [Resumo](#resumo)

Nesta publica√ß√£o, apresentei brevemente os tempos de vida dispon√≠veis na abstra√ß√£o _Microsoft.Extensions.DependencyInjection_ usada no ASP.NET Core. Em seguida, descrevi brevemente alguns tempos de vida hipot√©ticos adicionais discutidos por Khalid, Maarten e Woody no [The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/): servi√ßos com escopo de locat√°rio, pooling e baseados em tempo.

Por fim, mostrei duas varia√ß√µes de abordagens que voc√™ pode usar para implementar os servi√ßos baseados em tempo. No entanto, ambas as implementa√ß√µes apresentavam uma grande falha: voc√™ n√£o pode usar essa abordagem com servi√ßos `IDisposable`, pois o servi√ßo pode ser descartado enquanto ainda estiver em uso em uma solicita√ß√£o diferente. No pr√≥ximo post, mostro um exemplo de implementa√ß√£o para o tempo de vida agrupado.

---
