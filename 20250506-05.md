- **Cita√ß√£o**
  - **T√≠tulo**: Avoiding WPF Image Control Local File Locking
  - **Autor**: Rick Strahl
  - **Fonte**: Rick Strahl's Weblog
  - **URL**: https://weblog.west-wind.com/posts/2025/Apr/28/WPF-Image-Control-Local-File-Locking?utm_source=bonobopress&utm_medium=newsletter&utm_campaign=2048
  - **Atualizado**: 28 de abril de 2025

---

# [Evitando o bloqueio de arquivos locais do controle de imagem WPF](https://weblog.west-wind.com/posts/2025/Apr/28/WPF-Image-Control-Local-File-Locking)

O bloqueio de imagens do WPF me atrapalhou bastante em aplicativos XAML: o controle de imagem do WPF, por padr√£o, bloqueia arquivos de imagem ao vincular diretamente a um arquivo de imagem no disco. Quando voc√™ simplesmente vincula ou atribui um arquivo de imagem, internamente o WPF usa um fluxo que n√£o √© fechado e mantido aberto. Em alguns casos, isso n√£o importa, por exemplo, se suas imagens raramente ou nunca s√£o atualizadas.

Mas em alguns casos isso importa: em v√°rios dos meus aplicativos, tenho **v√°rios √≠cones** que s√£o carregados em um controle TreeView, sendo os √≠cones relacionados a modelos definidos pelo usu√°rio que podem ser atualizados (e frequentemente s√£o). Os arquivos bloqueados se tornam um problema, pois n√£o podem ser exclu√≠dos. Em um caso de uso espec√≠fico, atualizo meus modelos destruindo a pasta original, recriando-a e copiando os novos modelos que incluem as imagens de √≠cones potencialmente atualizadas. Com o comportamento de bloqueio padr√£o, isso falha, pois os arquivos bloqueados e o diret√≥rio pai n√£o podem ser exclu√≠dos ou copiados.

Pode haver outros cen√°rios tamb√©m: em alguns casos, voc√™ pode usar um √∫nico arquivo de imagem que √© atualizado pelo aplicativo e precisa ser exibido novamente ap√≥s a altera√ß√£o quando a imagem √© recuperada.

Se voc√™ n√£o conseguir atualizar a imagem, nada disso funciona. Existem maneiras de fazer isso funcionar, mas infelizmente o comportamento padr√£o √© que o arquivo fique bloqueado. E, como costuma acontecer quando voc√™ come√ßa a criar um novo controle ou formul√°rio, voc√™ n√£o pensa em problemas de bloqueio ‚Äî isso s√≥ acaba te prejudicando mais tarde. E nesses casos, eu costumava passar um tempo me debatendo para lembrar exatamente quais configura√ß√µes precisavam ser alteradas.

Esta postagem do blog tem como objetivo reunir tudo isso em um s√≥ lugar para que meu eu envelhecido possa encontrar e lembrar com mais facilidade üòÑ

## [Usando o controle de imagem com uma BitmapImage incorporada](#using-the-image-control-with-an-embedded-bitmapimage)

A primeira solu√ß√£o √© integrada e funciona apenas com XAML. √â um pouco prolixa, mas, fora isso, muito simples.

Em vez de vincular uma imagem como esta:

```xml
<Image Source={Binding TopicState.DisplayTypeIconFile} />
```

que se vincula diretamente a um arquivo no disco como uma string e bloqueia o arquivo de imagem, voc√™ pode vincular a uma fonte de Bitmap na qual pode controlar o comportamento do cache:

```xml
<Image Height="16">
    <Image.Source>
        <BitmapSource
            UriSource={Binding TopicState.DisplayTypeIconFile}
            CacheOption="OnLoad"
     />
    </Image.Source>
</Image>
```

Isso carrega a imagem na mem√≥ria na vincula√ß√£o e libera o fluxo de arquivo subjacente, o que resolve o problema de bloqueio.

Se voc√™ tamb√©m precisar garantir que a imagem seja atualizada, voc√™ precisa adicionar:

```xml
<BitmapSource
    UriSource={Binding TopicState.DisplayTypeIconFile}
    CacheOption="OnLoad"
    CreateOptions="IgnoreImageCache"
 />
```

Isso for√ßa a imagem a recarregar sempre que for revinculada. Isso n√£o √© bom para o desempenho, ent√£o tome cuidado e use somente quando necess√°rio, pois adiciona sobrecarga a cada opera√ß√£o de revincula√ß√£o.

## [Mais gen√©rico: usando um conversor de vincula√ß√£o como intermedi√°rio](#more-generic-using-a-binding-converter-as-in-intermediary)

Outra maneira de fazer isso √© por meio de um **Conversor de Vincula√ß√£o** que lida com esse comportamento e permite liberar as imagens subjacentes em cache explicitamente para for√ßar o recarregamento das imagens quando a lista for recuperada.

A ideia aqui √© que voc√™ possa usar um conversor em um caminho de imagem. A vantagem do conversor √© que voc√™ tem mais controle sobre o processo de cria√ß√£o da imagem e pode faz√™-lo consistentemente para muitas imagens usando a mesma l√≥gica. Ele tamb√©m pode armazenar imagens em cache para que imagens reutilizadas n√£o sejam recarregadas.

Por exemplo, gosto de armazenar imagens em cache, pois no meu aplicativo reutilizo v√°rios √≠cones para visualiza√ß√µes de √°rvores complexas:

![√çcones na visualiza√ß√£o em √°rvore](./imagens/IconsInTreeView.png)

**Figura 1** - Uma TreeView com muitas imagens repetidas que s√£o armazenadas em cache e reutilizadas

Os √≠cones s√£o armazenados em cache, de modo que cada √≠cone exclusivo √© essencialmente carregado de uma √∫nica inst√¢ncia `BitmapImage`, o que economiza recursos e carrega visivelmente mais r√°pido.

Veja como fica o controle de imagem usando o conversor em um formul√°rio XAML:

```xml
<UserControl.Resources>
    <windows:LocalFileImageConverter x:Key="LocalFileImageConverter"/>
<UserControl.Resources>

...

<Image Height="16"
       Source="{Binding TopicState.OpenImageFilename,
                Converter={StaticResource LocalFileImageConverter}}"
/>
```

### [Uma classe LocalFileImageConverter](#a-localfileimageconverter-class)

Este conversor recebe um link de arquivo local como uma string e o transforma em `BitmapImage`. Se uma imagem n√£o puder ser encontrada, uma imagem padr√£o √© retornada. Este conversor √© usado especificamente para imagens de √≠cones no Markdown Monster e no Documentation Monster. As imagens s√£o armazenadas em cache, de modo que qualquer refer√™ncia a um √≠cone √© reutilizada se for referenciada v√°rias vezes, como √© o caso na **Figura 1**.

```c#
public class LocalFileImageConverter : IValueConverter
{
    public  static Dictionary<string, BitmapImage> CachedBitmapImages = new Dictionary<string, BitmapImage>();

    public static void ClearCachedImages()
    {
        CachedBitmapImages = new Dictionary<string, BitmapImage>();
    }

    public object Convert(object value, Type targetType,
                          object parameter, System.Globalization.CultureInfo culture)
    {
        string val = value as string;

        if (!string.IsNullOrEmpty(val))
        {
            val = ((string)value).ToLower();

            if (CachedBitmapImages.TryGetValue(val, out BitmapImage bi))
                return bi;

            try
            {
                using (var fstream = new FileStream(value.ToString(), FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    bi = new BitmapImage();
                    bi.BeginInit();
                    bi.CacheOption = BitmapCacheOption.OnLoad;
                    bi.StreamSource = fstream;
                    bi.StreamSource.Flush();
                    bi.EndInit();
                    bi.Freeze();

                    bi.StreamSource.Dispose();
                }
                CachedBitmapImages.Add(val, bi);
                return bi;
            }
            catch {
            }

            return AssociatedIcons.DefaultIcon;
        }
        //if (val != null)
        //    CachedBitmapImages.Add(val, null);
        return null;
    }

    public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        throw new NotImplementedException("LocalFileImageConverter: Two way conversion is not supported.");
    }
}
```

#### [Carregamento de imagem sem bloqueio](#non-locking-image-loading)

H√° algumas coisas interessantes. A primeira √© o carregamento da imagem, que √© personalizado para carregamento sem cache, o que garante que a imagem n√£o fique bloqueada no disco:

```c#
using (var fstream = new FileStream(value.ToString(), FileMode.Open, FileAccess.Read, FileShare.Read))
{
    bi = new BitmapImage();
    bi.BeginInit();
    bi.CacheOption = BitmapCacheOption.OnLoad;
    bi.StreamSource = fstream;
    bi.StreamSource.Flush();
    bi.EndInit();
    bi.Freeze();  // optional optimization
}
CachedBitmapImages.Add(val, bi);
return bi;
```

Observe que este c√≥digo libera explicitamente o fluxo e congela a imagem. Descobri que, em algumas situa√ß√µes, a falta de libera√ß√£o fazia com que o fluxo permanecesse aberto. A libera√ß√£o for√ßa a leitura para o final. `Freeze()` otimiza o uso da imagem, pois remove quaisquer ganchos e verifica√ß√µes de vincula√ß√£o. Suspeito que isso tenha pouco efeito, j√° que a BitmapImage n√£o est√° vinculada diretamente, mas `Freeze` n√£o faz mal.

#### [Limpando o cache para atualizar imagens](#clearing-the-cache-to-refresh-images)

Outro recurso √∫til √© que o cache pode ser limpo para que a imagem possa ser atualizada explicitamente. Cada inst√¢ncia de `BitmapImage` √© armazenada em um dicion√°rio est√°tico em cache, indexado pelo caminho. Assim, v√°rias imagens que referenciam o mesmo caminho reutilizam a mesma inst√¢ncia de `BitmapImage`.

√â poss√≠vel limpar o cache de imagens para for√ßar o recarregamento de todas as imagens do disco, ou voc√™ pode acessar diretamente o dicion√°rio e remover um caminho individual e `BitmapImage`. Na pr√≥xima vez que esta imagem for reassociada, ela ser√° recarregada do disco. Se a imagem tiver sido alterada, a imagem atualizada dever√° ser renderizada. Observe que voc√™ precisa acionar a atualiza√ß√£o e, potencialmente, a reassocia√ß√£o nos controles que s√£o vinculados usando o conversor.

## [Resumo](#summary)

Carregar imagens do disco geralmente √© desaprovado no WPF. O WPF prefere carregar coisas de recursos compilados, mas se voc√™ tiver arquivos configur√°veis pelo usu√°rio, como √≠cones ou imagens personalizados, arquivos externos s√£o necess√°rios para que isso funcione. E nesses cen√°rios, √© especialmente importante que os arquivos n√£o sejam bloqueados quando precisam ser atualizados, j√° que esses arquivos externos podem ser atualizados (e frequentemente o s√£o) individualmente como parte da opera√ß√£o do aplicativo ou, como no meu caso, em uma opera√ß√£o de atualiza√ß√£o de modelos em massa.

Os controles `<Image>` e `<BitmapImage>` t√™m algum suporte integrado para evitar travamentos, mas s√£o bastante prolixos e, pelo menos para mim, dif√≠ceis de lembrar. Pessoalmente, prefiro um conversor que garanta universalmente que as imagens sejam carregadas e armazenadas em cache da mesma maneira.

Este conversor `LocalFileImageConverter` √© uma ferramenta antiga, mas, atualmente, eu o uso para praticamente qualquer aplicativo que utilize um controle TreeView ou List com √≠cones. Mas tamb√©m funciona para outros tipos de imagens carregadas do disco... desde que eu **lembre**. Espero que este post ajude. üòÑ

---
