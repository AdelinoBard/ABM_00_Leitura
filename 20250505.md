- **Cita√ß√£o**
  - **T√≠tulo**: Why C#?
  - **Autor**: Dr Milan Milanoviƒá
  - **Fonte**: Tech World With Milan Newsletter
  - **URL**: https://newsletter.techworld-with-milan.com/p/why-csharp
  - **Atualizado**: 24 de abril de 2025

---

# Por que C#?

24 de abril de 2025

Eu poderia ter ficado c√©tico se algu√©m me dissesse anos atr√°s que **[C#](<https://en.wikipedia.org/wiki/C_Sharp_(programming_language)>)** se tornaria minha linguagem de programa√ß√£o preferida para a maioria dos projetos. Como muitos desenvolvedores, explorei v√°rias linguagens ao longo da minha carreira ‚Äî desde C++ de baixo n√≠vel at√© Java, a rainha das empresas. Mesmo assim, continuo voltando para C#, e muitas pessoas me perguntam por qu√™.

[C#](<https://en.wikipedia.org/wiki/C_Sharp_(programming_language)>) foi a resposta da Microsoft ao Java durante a guerra de plataformas do in√≠cio dos anos 2000, mas rapidamente se tornou algo que o Java nunca conseguiu. Foi projetada como uma linguagem fortemente tipada que combinava a robustez do C++ com a simplicidade do Visual Basic.

Ao contr√°rio de algumas linguagens que lutam para evoluir, o C# tem sido continuamente refinado, adaptando-se aos paradigmas de programa√ß√£o modernos, mas mant√©m a compatibilidade com vers√µes anteriores.

Algumas pessoas costumam me perguntar por que escolhi C# em vez de muitas outras linguagens, e neste texto tentarei explicar o porqu√™.

![Linha do tempo do C# 1.0 ao C# 13.0](../ABM_00_Leitura/imagens/f1600cfa-21f2-441f-9b2c-d48c47bfefb3_6446x1467.webp)

Discutiremos o seguinte:

1. **O que √© C#?** Uma vis√£o geral das origens, objetivos, principais caracter√≠sticas e filosofia de design do C#.
2. **A linguagem**. Discutiremos recursos essenciais do C#, incluindo programa√ß√£o orientada a objetos, sistema de tipos, gen√©ricos, lambdas, LINQ, async/await e gerenciamento de mem√≥ria.
3. **O ecossistema .NET.** Exploraremos o ecossistema em que o C# se encontra, seus diferentes tempos de execu√ß√£o e as estruturas que permitem que ele atenda a diversos dom√≠nios de aplica√ß√£o.
4. **Ferramentas**. Analisaremos ferramentas de desenvolvimento e IDEs populares, como Visual Studio, Visual Studio Code, JetBrains Rider e .NET CLI.
5. **Bibliotecas**. Exploraremos as bibliotecas padr√£o do .NET e os pacotes populares de terceiros dispon√≠veis via NuGet.
6. **Documenta√ß√£o**. Quais s√£o alguns recursos dispon√≠veis e populares, documenta√ß√£o oficial e materiais recomendados para aprender C# e .NET?
7. **Comunidade**. Responderemos √†s perguntas sobre que tipo de comunidade o C# possui e quais s√£o as iniciativas, recursos e plataformas essenciais que d√£o suporte aos desenvolvedores.
8. **O concurso de popularidade**. Verificaremos a popularidade do C#, suas classifica√ß√µes, relev√¢ncia para o mercado de trabalho, sal√°rios e percep√ß√£o da comunidade.
9. **C# vs. outras linguagens**. Como C# se compara a Java, Python, F# e JavaScript/TypeScript.
10. **O futuro do C#.** Qual √© a evolu√ß√£o futura do C#, os avan√ßos recentes da linguagem e a vis√£o da Microsoft para inova√ß√£o cont√≠nua.
11. **Conclus√£o**. Minhas ideias sobre por que C# √© uma boa escolha e adequada para diversos cen√°rios de desenvolvimento.
12. **B√¥nus: Uma breve hist√≥ria do C#**. Uma linha do tempo hist√≥rica destacando marcos significativos na evolu√ß√£o da linguagem C#.

Ent√£o, vamos come√ßar.

## 1. O que √© C#?

C# (pronuncia-se "C-sharp") √© uma linguagem de programa√ß√£o moderna e multiparadigma desenvolvida pela Microsoft. Criada por Anders Hejlsberg e sua equipe como parte da iniciativa .NET (ele lidera o TypeScript atualmente), C# foi projetada desde o in√≠cio para ser orientada a objetos, orientada a componentes e com tipagem segura.

> üí° _O pr√≥prio nome tem uma origem interessante **‚Äî √© uma refer√™ncia musical.** O s√≠mbolo '#' indica que um semitom deve elevar uma nota na nota√ß√£o musical. Portanto, "C#" sugere que a linguagem √© um **"incremento" em rela√ß√£o a C/C++**. O s√≠mbolo # tamb√©m se assemelha habilmente a quatro sinais "+" empilhados, sugerindo que C# √© "C++++"._

[![O que √© C#?](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff7a78b20-7f53-45bc-b292-eebf154772ef_3938x2475.svg "O que √© C#?")](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff7a78b20-7f53-45bc-b292-eebf154772ef_3938x2475.svg)

Quando o C# foi lan√ßado, um programa simples do tipo "Hello World" exigia v√°rias linhas de c√≥digo com namespaces, classes e declara√ß√µes de m√©todos. Mas, √† medida que a linguagem evoluiu, ela se tornou mais simples. Com as instru√ß√µes de n√≠vel superior do C# 9, o programa C# mais simples agora pode ser escrito como:

![](./imagens/0452c6a4-99a2-4b6c-a41f-e9b6f339fb64_1242x360.webp)

N√£o √© √≥timo? Uma linguagem multiplataforma super-rica pode ter um programa de uma linha.

Em sua ess√™ncia, C# √©:

- **Moderno**: Atualizado continuamente com novos recursos que refletem o cen√°rio de programa√ß√£o em evolu√ß√£o
- **Maduro**: Tem 25 anos e evoluiu significativamente, mas ainda est√° ativo em desenvolvimento.
- **Tipo seguro**: Evita erros de tipo por meio de seu sistema de tipos forte.
- **Multiparadigma**: √â uma linguagem fortemente orientada a objetos, que inclui estilos de programa√ß√£o imperativos, declarativos e funcionais.
- **Orientado a componentes**: Suporta o desenvolvimento de componentes autocontidos e reutiliz√°veis.
- **Multiplataforma**: embora inicialmente reservado para Windows, agora pode ser executado em Linux, Mac e outras plataformas.
- **Vers√°til**: Adequado para desenvolver uma ampla gama de aplicativos, da web ao celular e ao desktop
- **C√≥digo aberto:** desde a vers√£o 7, o C# tem sido totalmente desenvolvido abertamente no GitHub, e a Microsoft aceita coment√°rios e propostas da comunidade na **[p√°gina oficial do C# no GitHub](https://github.com/dotnet/csharplang)**.
- **Leg√≠vel:** C# reconhece que os desenvolvedores passam mais tempo lendo c√≥digo do que escrevendo. A linguagem foi projetada desde o in√≠cio com a legibilidade em mente, facilitando a colabora√ß√£o das equipes e a manuten√ß√£o de bases de c√≥digo ao longo do tempo.

O compilador C# gera c√≥digo de **Linguagem Intermedi√°ria (IL)** que √© executado no **Common Language Runtime (CLR)**, que faz parte do **tempo de execu√ß√£o do .NET** (tamb√©m compartilhado com outras linguagens, como F# e Visual Basic).

Essa abordagem oferece benef√≠cios como gerenciamento autom√°tico de mem√≥ria, seguran√ßa de tipo e acesso a uma biblioteca padr√£o abrangente.

![](./imagens/ea4c5a97-abab-4402-bd76-59d83f34db95_491x673.webp)

Arquitetura do .NET Framework (Fonte: [Microsoft](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet-framework))

## 2. A Linguagem

O que me atraiu inicialmente para C# n√£o foi sua sintaxe (que era familiar aos desenvolvedores Java e C++), mas suas boas escolhas de design. Ao longo dos anos, C# deixou de ser uma linguagem simples orientada a objetos e se tornou uma linguagem muito mais rica.

Esta linguagem utiliza m√∫ltiplos paradigmas de programa√ß√£o com o mesmo n√∫cleo da primeira vers√£o.

Vamos dar uma olhada no b√°sico:

![](./imagens/3bdffc44-1f17-4c10-99c2-6f660ea76701_2442x4185.webp)

F√°cil de entender, incluindo at√© mesmo alguns recursos de linguagem moderna.

Mas vamos dar uma olhada em algo mais interessante:

![](./imagens/a42147fd-d123-465d-8b05-4b8736f7bb7a_2751x2288.webp)

Este √∫nico arquivo mostra como o C# moderno equilibra brevidade com clareza (usando LINQ, que descreveremos em breve). Fenomenal!

Um aspecto not√°vel do C# √© a sua capacidade de **encapsular a complexidade**. Voc√™ pode usar com sucesso recursos avan√ßados como iteradores, async/await ou LINQ sem entender completamente os detalhes internos de sua implementa√ß√£o.

Isso aplica o **princ√≠pio de encapsulamento orientado a objetos √† linguagem**, permitindo que os desenvolvedores usem recursos modernos de forma produtiva, sem conhecer todos os detalhes da implementa√ß√£o.

> üëâ _Confira minha **[folha de dicas de C#](https://github.com/milanm/csharp-cheatsheet)** completa se quiser uma refer√™ncia r√°pida de sintaxe. Eu a criei como um complemento para esta edi√ß√£o do boletim informativo._
>
> [![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fdc1b9bb8-5dac-4359-b9d4-4d64da273727_280x553.png)](https://github.com/milanm/csharp-cheatsheet)

Ent√£o, vamos dar uma olhada nas caracter√≠sticas mais importantes do C#:

### Fundamentos orientados a objetos

Em sua ess√™ncia, **C# √© uma linguagem de programa√ß√£o orientada a objetos** constru√≠da em torno dos princ√≠pios de **encapsulamento, heran√ßa e polimorfismo** desde o primeiro dia.

Voc√™ define **[classes](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)** para modelar entidades do mundo real ou conceitos abstratos, agrupando estado (campos/propriedades) e comportamento (m√©todos). Voc√™ cria **objetos (inst√¢ncias)** dessas classes para usar em tempo de execu√ß√£o.

C# tamb√©m oferece suporte a **[interfaces](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces)** (contratos abstratos que classes podem implementar) e **classes abstratas** (classes base que fornecem alguma implementa√ß√£o, mas n√£o s√£o instanci√°veis).

Por exemplo, considere uma hierarquia de classes simples:

![](./imagens/e6705a9d-6c67-40d2-9b94-28fa660f444d_2193x1233.webp)

Aqui, `Animal`. A classe base abstrata define um conceito geral de um animal com um Nome e um comportamento de Fala, mas o som real √© deixado abstrato. `Cachorro` e `Gato` herdam de `Animal` e fornecem implementa√ß√µes concretas de `Speak()`.

Isso demonstra:

- **Heran√ßa** (Cachorro _√©_ um Animal)
- **Polimorfismo** (um m√©todo se comporta de maneira diferente dependendo do tipo derivado real) e
- **Encapsulamento** (cada classe encapsula seus detalhes de implementa√ß√£o ‚Äì por exemplo, as especifica√ß√µes de `Speak()`).

Em um programa C#, pode-se escrever:

![](./imagens/cd9ae8b5-c0e1-4e7e-b4d8-540e19a84c5a_1359x600.webp)

Devido ao polimorfismo, a chamada para `pet.Speak()` invoca a substitui√ß√£o correta com base no tipo de tempo de execu√ß√£o (Cachorro ou Gato).

C# torna esse tipo de c√≥digo orientado a objetos f√°cil e seguro em termos de tipos.

### Sistema de tipos

O sistema de tipos do C# evoluiu de um sistema de tipos est√°ticos relativamente simples para algo muito mais sofisticado, com gen√©ricos, tipos anul√°veis, correspond√™ncia de padr√µes e registros.

A introdu√ß√£o de **[tipos de refer√™ncia anul√°veis](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references) no C# 8.0** foi cr√≠tica porque nos ajudou a evitar um dos erros de tempo de execu√ß√£o mais comuns na programa√ß√£o orientada a objetos: a famosa `NullReferenceException`.

![](./imagens/693d5cad-2c46-4379-84cf-2f60478314a3_2037x960.webp)

O [sistema de tipos](https://learn.microsoft.com/en-us/dotnet/standard/base-types/common-type-system) do C# ajuda a detectar erros em tempo de compila√ß√£o, ao mesmo tempo que nos permite escrever c√≥digo expressivo.

### Gen√©ricos

Uma das primeiras adi√ß√µes significativas ao C# foram os **[gen√©ricos](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics)** (adicionados no C# 2.0). Os gen√©ricos permitem definir classes e m√©todos com espa√ßos reservados para tipos, permitindo um c√≥digo mais reutiliz√°vel e com tipagem mais segura.

Por exemplo, se voc√™ quiser uma lista de itens, pode usar a classe interna `List<T>` ‚Äì onde `T` pode ser qualquer tipo. Isso significa que voc√™ n√£o precisa criar classes separadas como `IntList`, `StringList`, etc., e voc√™ obt√©m verifica√ß√£o de tipo em tempo de compila√ß√£o para qualquer tipo que usar.

Aqui est√° uma demonstra√ß√£o simples de uma classe e m√©todo gen√©ricos:

![](./imagens/ff0548f2-0df6-4de1-93a5-54e4680c44cb_1494x750.webp)

Definimos uma classe gen√©rica `Box<T>` que pode conter um `Value` de qualquer tipo `T`. Tamb√©m temos um m√©todo gen√©rico, `Echo<T>`, que simplesmente retorna o valor de entrada (de qualquer tipo).

Podemos usar esses gen√©ricos assim:

![](./imagens/4de37739-37ce-49d2-9f51-546f254a0f58_2331x750.webp)

Gen√©ricos permitem **polimorfismo param√©trico** ‚Äì nosso c√≥digo funciona com qualquer tipo, mas permanece **seguro em rela√ß√£o a tipos**. O compilador garante que voc√™ coloque apenas um `int` em um `Box<int>`, uma `string` em `Box<string>` e assim por diante. N√£o h√° convers√£o em tempo de execu√ß√£o ao recuperar `Value`; ele j√° √© o tipo correto, evitando exce√ß√µes de convers√£o de classe que eram comuns antes dos gen√©ricos.

### Express√µes lambda

Por volta de 2007, o C# come√ßou a incorporar mais conceitos de programa√ß√£o funcional para complementar seu lado orientado a objetos (influ√™ncia do [F#](https://fsharp.org/)).

A introdu√ß√£o de **[express√µes lambda](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions)** no C# 3.0 foi um momento cr√≠tico. Uma express√£o lambda √© uma **fun√ß√£o an√¥nima** ‚Äì uma parte do c√≥digo que voc√™ pode tratar como dados: pass√°-la adiante, armazen√°-la em uma vari√°vel, cham√°-la posteriormente, etc. Lambdas trazem um pouco de "a√ß√∫car sint√°tico" funcional que torna tarefas espec√≠ficas muito mais concisas e expressivas.

Para entender a import√¢ncia, pense em como voc√™ realizaria uma tarefa simples: _filtrar uma lista de n√∫meros para obter apenas os pares_.

Antes de lambdas (e LINQ), voc√™ pode escrever:

![](./imagens/166bb022-c4a9-46b6-a313-7d20bf7e581a_1881x750.webp)

Isso funciona, mas √© um pouco complexo de escrever. Com lambdas, voc√™ pode fazer:

![](./imagens/16ea803b-4650-4de8-9acc-53e9dbbf7ee2_1764x390.webp)

Aqui `x => x * x` define uma fun√ß√£o an√¥nima que eleva ao quadrado sua entrada, e a atribu√≠mos ao delegado `square`.

T√£o poderoso!

### LINQ

Talvez o recurso matador que fez muitos desenvolvedores se apaixonarem por C# seja o **[LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)** (Consulta Integrada √† Linguagem). Introduzido no C# 3.0, o LINQ √© um conjunto de recursos de linguagem e framework que permite **consultar e manipular dados declarativamente**.

Se voc√™ j√° escreveu consultas SQL, o LINQ parecer√° familiar, exceto pelo fato de que voc√™ pode us√°-lo em todos os tipos de dados (cole√ß√µes na mem√≥ria, tabelas de banco de dados, documentos XML, etc.) diretamente do c√≥digo C#, com verifica√ß√£o em tempo de compila√ß√£o e IDE IntelliSense.

**Por exemplo**, _voc√™ tem uma lista de_ objetos `Livro` e quer encontrar todos os livros escritos por um autor espec√≠fico, orden√°-los por t√≠tulo e selecionar apenas os t√≠tulos. Sem LINQ, voc√™ escreveria loops aninhados ou usaria m√©todos de biblioteca manualmente.

Com LINQ, √© simples:

![](./imagens/d716ad47-51ce-41e7-9f93-2cb3ed00e4db_1557x540.webp)

Em uma declara√ß√£o fluente, filtramos (`Where`), classificamos (`OrderBy`) e projetamos (`Select`) os dados. Isso se parece muito com a pr√≥pria declara√ß√£o do problema.

H√° tamb√©m uma **sintaxe de compreens√£o de consulta** que se parece ainda mais com SQL:

![](./imagens/b0d9d6f1-57dd-464e-8952-1233c5ee4819_1236x600.webp)

Nos bastidores, ambas as formas s√£o equivalentes. O LINQ funciona usando m√©todos de extens√£o e lambdas (os m√©todos `Where`, `OrderBy` e `Select` mostrados s√£o m√©todos de extens√£o em `IEnumerable<T>` que aceitam express√µes lambda).

O compilador C# pode at√© mesmo traduzir a _√°rvore de express√µes_ de uma consulta LINQ para outros formatos ‚Äì por exemplo, ao consultar um banco de dados via LINQ para SQL ou Entity Framework, as express√µes lambda s√£o convertidas em uma consulta SQL enviada ao banco de dados.

Isso √© poderoso: **voc√™ pode usar uma sintaxe de consulta unificada para cole√ß√µes na mem√≥ria, bancos de dados relacionais, XML (com LINQ para XML) e muito mais**.

Por exemplo, `employees.Where(e => e.Salary > 100000)` pode estar filtrando uma lista na mem√≥ria ou pode ser traduzido para uma cl√°usula SQL `WHERE` para ser executada em um banco de dados ‚Äì de qualquer forma, voc√™, como programador, expressa a inten√ß√£o.

> **üîç Nos bastidores:** _LINQ funciona por meio de **execu√ß√£o adiada** e **iteradores**. M√©todos como_ `Where` _e_ `Select` _n√£o produzem um resultado imediatamente; eles retornam_ `IEnumerable<T>` _que, quando iterado, produzir√° os resultados filtrados ou transformados imediatamente._
>
> _Isso significa que as consultas LINQ s√£o eficientes em termos de mem√≥ria (elas n√£o necessariamente criam novas listas at√© que voc√™ force uma avalia√ß√£o, por exemplo, chamando_ `.ToList()` _ou iterando em_ `foreach`_). Isso tamb√©m significa que voc√™ pode compor consultas dinamicamente._

### Programa√ß√£o ass√≠ncrona

Lidar com opera√ß√µes ass√≠ncronas (como E/S de arquivos, chamadas de rede ou qualquer tarefa de longa dura√ß√£o que n√£o devesse bloquear a thread principal) era complicado em C#. Anteriormente, precis√°vamos usar threads, callbacks ou eventos para gerenciar o trabalho de sincroniza√ß√£o. Essas abordagens complexas levaram ao "**inferno dos callbacks**".

O C# resolveu isso introduzindo o padr√£o **[async/await](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/)** no C# 5.0, que desde ent√£o se tornou o padr√£o ouro para programa√ß√£o ass√≠ncrona em muitas linguagens.

Async/await n√£o apenas melhora o desempenho ‚Äî **ele fornece uma maneira intuitiva de implementar programa√ß√£o ass√≠ncrona** ‚Äî, mas tamb√©m mant√©m um n√≠vel de produtividade semelhante ao que ocorre quando escrevemos c√≥digo s√≠ncrono. Esse padr√£o √© incorporado diretamente √† linguagem, facilitando a utiliza√ß√£o de um desafio de programa√ß√£o tradicionalmente complexo.

Funciona da seguinte maneira: voc√™ pode marcar um m√©todo com `async` e usar a palavra-chave `await` dentro dele para pausar a execu√ß√£o at√© que uma opera√ß√£o ass√≠ncrona seja conclu√≠da, sem bloquear a thread. Aqui, o compilador transforma seu c√≥digo em uma m√°quina de estados nos bastidores. Para voc√™, parece que est√° escrevendo c√≥digo sequencial; por baixo dos panos, √© n√£o bloqueante e eficiente.

**Exemplo:** Suponha que queremos baixar o conte√∫do de uma p√°gina da web e, em seguida, contar o n√∫mero de caracteres. Usando `HttpClient` do C#, que possui m√©todos ass√≠ncronos, ficaria assim:

![](./imagens/3e68656b-8296-4bc1-991b-b93b84341e94_2364x1080.webp)

Quando `client.GetStringAsync(url)` √© chamado, ele inicia uma opera√ß√£o de E/S. A palavra-chave `await` informa ao compilador: "ap√≥s o in√≠cio desta opera√ß√£o, retorne o controle ao chamador at√© que ela seja conclu√≠da e, em seguida, retome". A thread pode realizar outras tarefas (ou, se for a thread da interface do usu√°rio, pode manter a interface do usu√°rio responsiva). Quando o download for conclu√≠do, o restante do m√©todo (calculando `content.Length` e retornando-o) ser√° executado, possivelmente no contexto original.

Esse estilo linear √© _muito mais simples_ do que configurar um retorno de chamada ou criar manualmente um thread para fazer o download e, de alguma forma, sincronizar de volta.

Antes do async/await, o .NET tinha o **Modelo de Programa√ß√£o Ass√≠ncrona (APM)** `BeginOperation/EndOperation` e o Padr√£o Ass√≠ncrono Baseado em Eventos (EAP) ‚Äì ambos eram mais complexos. O async/await unificava tudo em um modelo simples.

> **‚Ñπ Ô∏è Outros recursos de simultaneidade:** C# possui um modelo de programa√ß√£o ass√≠ncrona rico que vai al√©m de apenas await. H√° os tipos `Task` e `Task<T>` (da Biblioteca Paralela de Tarefas) que representam opera√ß√µes ass√≠ncronas e podem ser usados com ou sem a palavra-chave `async`.
>
> _Existem bibliotecas de fluxo de dados, fluxos ass√≠ncronos (o C# 8 adicionou_ `await foreach` _para iterar resultados de forma ass√≠ncrona, por exemplo, lendo de um fluxo de eventos) e muito mais. Mas, para a maioria dos casos, especialmente ao lidar com opera√ß√µes que n√£o exigem muita CPU, async/await √© a melhor op√ß√£o._

### Gerenciamento de mem√≥ria

Gerenciar a mem√≥ria com efici√™ncia √© crucial para o desempenho e a estabilidade de qualquer aplicativo. C# simplifica esse aspecto cr√≠tico do desenvolvimento de software por meio de seu sistema de gerenciamento autom√°tico de mem√≥ria, facilitado pelo coletor de lixo do **Common Language Runtime (CLR)**.

Ao contr√°rio de linguagens como C e C++, nas quais os desenvolvedores precisam alocar e desalocar mem√≥ria manualmente, C# automatiza esse processo. O coletor de lixo varre periodicamente a mem√≥ria do aplicativo, identificando e recuperando o espa√ßo ocupado por objetos que n√£o est√£o mais sendo usados ou referenciados pelo programa. Esse processo autom√°tico reduz significativamente o risco de vazamentos de mem√≥ria, um problema comum em ambientes de mem√≥ria gerenciados manualmente.

**O coletor de lixo** utiliza um sistema geracional para maior efici√™ncia. Todos os novos objetos come√ßam na Gera√ß√£o 0. Os objetos que sobrevivem √† coleta passam para a Gera√ß√£o 1, e os objetos persistentes eventualmente chegam √† Gera√ß√£o 2. Essa abordagem otimiza a coleta, j√° que objetos mais novos tendem a ter vida √∫til mais curta.

Para objetos grandes (mais de 85.000 bytes), o C# usa um _Large Object Heap_ (LOH) separado que faz parte da Gera√ß√£o 2. Diferentemente do heap normal, o LOH n√£o compacta a mem√≥ria durante a coleta, o que pode levar √† fragmenta√ß√£o.

Em C#, a mem√≥ria √© gerenciada principalmente em duas regi√µes: **a pilha e o heap**. A pilha armazena tipos de valor (como inteiros e booleanos) e informa√ß√µes de chamadas de m√©todos. A mem√≥ria na pilha √© gerenciada de forma LIFO (√∫ltimo a entrar, primeiro a sair) e √© alocada e desalocada automaticamente quando um m√©todo √© chamado e retorna. O heap, por outro lado, armazena tipos de refer√™ncia (como objetos e strings).

> **üìå Observa√ß√£o:** _Embora o C# ofere√ßa recursos sofisticados de gerenciamento de mem√≥ria, √© importante observar **que a otimiza√ß√£o prematura raramente √© necess√°ria**. Para a maioria dos aplicativos, a legibilidade e a manutenibilidade do seu c√≥digo devem ter preced√™ncia sobre o desempenho hiperotimizado._
>
> _O compilador JIT **j√° gera c√≥digo de m√°quina altamente eficiente em tempo de execu√ß√£o**, que √†s vezes pode superar o c√≥digo compilado antecipadamente em C e C++._
>
> _Desde o .NET 7, **[a compila√ß√£o Native AOT (Ahead-Of-Time)](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=windows%2Cnet8)** oferece uma op√ß√£o adicional para cen√°rios que exigem tempos de inicializa√ß√£o mais r√°pidos e menor consumo de mem√≥ria, permitindo que os aplicativos sejam executados sem depender do tempo de execu√ß√£o do .NET._

![Gerenciamento de mem√≥ria .NET](./imagens/3ac5fe24-f11c-42ef-b810-2bdcb8959c7e_1382x1202.webp)

> üëâ _Um conjunto completo de recursos est√° documentado no **[guia da linguagem C#](https://learn.microsoft.com/en-us/dotnet/csharp/)**._

### Outros recursos importantes do C#

Al√©m dos recursos j√° discutidos, C# oferece um rico conjunto de outras constru√ß√µes de linguagem que contribuem para seu poder e permitem a produtividade do desenvolvedor:

- ‚úÖ **[Propriedades](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties)** oferecem uma maneira limpa de acessar e alterar dados de classe. Em vez de acesso direto a campos, voc√™ escreve acessadores get e set que podem incluir l√≥gica de valida√ß√£o. Isso ajuda a manter o encapsulamento adequado, ao mesmo tempo em que fornece uma sintaxe simples como `object.Property = value`. As propriedades parecem campos para os chamadores, mas podem executar c√≥digo quando lidas ou modificadas.

```csharp
using System;

class Pessoa
{
    private string nome;

    public string Nome
    {
        get { return nome; }
        set
        {
            if (!string.IsNullOrWhiteSpace(value))
                nome = value;
            else
                throw new ArgumentException("O nome n√£o pode ser vazio ou nulo.");
        }
    }
}

class Program
{
    static void Main()
    {
        Pessoa pessoa = new Pessoa();
        pessoa.Nome = "Adelino"; // Define o nome usando a propriedade
        Console.WriteLine(pessoa.Nome); // Obt√©m o nome usando a propriedade
    }
}
```

- Explica√ß√£o r√°pida:

  - A classe `Pessoa` tem um campo privado `nome`.
  - A propriedade `Nome` encapsula esse campo e fornece acesso controlado a ele.
  - O m√©todo `set` garante que o valor atribu√≠do n√£o seja nulo ou vazio, mantendo a integridade dos dados.

- ‚úÖ **[Registros](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record)** simplificam a cria√ß√£o de objetos de dados imut√°veis em C#. Introduzidos no C# 9, os registros usam uma sintaxe concisa como `record Person(string Name, int Age);` para definir tipos de refer√™ncia com igualdade baseada em valor. Isso significa que dois registros s√£o iguais se suas propriedades corresponderem, o que n√£o √© verdade para classes, onde a igualdade de refer√™ncia √© o padr√£o.

```csharp
using System;

record Pessoa(string Nome, int Idade);

class Program
{
    static void Main()
    {
        Pessoa pessoa1 = new("Adelino", 30);
        Pessoa pessoa2 = new("Adelino", 30);

        Console.WriteLine(pessoa1 == pessoa2); // True, pois registros com mesmos valores s√£o iguais
        Console.WriteLine(pessoa1); // Sa√≠da autom√°tica formatada: Pessoa { Nome = Adelino, Idade = 30 }
    }
}
```

- Explica√ß√£o r√°pida:

  - O record `Pessoa` define um tipo de refer√™ncia imut√°vel.
  - O operador `==` verifica igualdade de valores, diferente das classes que usam igualdade de refer√™ncia.
  - `Console.WriteLine(pessoa1)` gera uma sa√≠da leg√≠vel automaticamente, sem necessidade de sobrescrever `ToString()`.

- ‚úÖ **[Delegates](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/)** funcionam como refer√™ncias de tipo seguro para m√©todos. Eles permitem armazenar m√©todos em vari√°veis, pass√°-los como argumentos e cham√°-los posteriormente. Isso potencializa callbacks e manipuladores de eventos. Delegates nos permitem ser flex√≠veis em designs onde podemos trocar comportamentos em tempo de execu√ß√£o sem alterar a estrutura da nossa classe.

```csharp
using System;

delegate void MensagemDelegate(string mensagem);

class Program
{
    static void ExibirMensagem(string mensagem)
    {
        Console.WriteLine($"Mensagem: {mensagem}");
    }

    static void Main()
    {
        MensagemDelegate meuDelegate = ExibirMensagem; // Atribui o m√©todo ao delegate
        meuDelegate("Ol√°, Adelino! Delegates s√£o incr√≠veis!"); // Chama o m√©todo atrav√©s do delegate
    }
}
```

- Explica√ß√£o r√°pida:

  - Criamos um **delegate** chamado `MensagemDelegate`, que aceita uma `string`.
  - Definimos um m√©todo `ExibirMensagem` que imprime uma mensagem.
  - No `Main()`, associamos o m√©todo ao delegate e o chamamos.

- ‚úÖ **[Tuplas](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)** fornecem uma maneira r√°pida de retornar v√°rios valores de m√©todos sem criar classes personalizadas. Podemos escrever `return (sum, count);` e, no lado receptor, usar `(int total, int n) = ComputeSumAndCount(data);`.

```csharp
using System;

class Program
{
    static (int, int) CalcularSomaEContagem(int[] numeros)
    {
        int soma = 0;
        int contagem = numeros.Length;

        foreach (int num in numeros)
        {
            soma += num;
        }

        return (soma, contagem); // Retorna m√∫ltiplos valores como uma tupla
    }

    static void Main()
    {
        int[] dados = { 10, 20, 30, 40 };
        (int total, int quantidade) = CalcularSomaEContagem(dados);

        Console.WriteLine($"Soma: {total}, Contagem: {quantidade}");
    }
}
```

- Explica√ß√£o r√°pida:

  - O m√©todo `CalcularSomaEContagem` retorna uma tupla contendo dois valores: a soma dos elementos e a quantidade de elementos no array.
  - No `Main()`, usamos **desconstru√ß√£o** para atribuir os valores diretamente a vari√°veis `total` e `quantidade`.

- ‚úÖ **[Correspond√™ncia de padr√µes](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching)** pode melhorar o fluxo de controle testando se os valores correspondem a padr√µes espec√≠ficos durante a extra√ß√£o de dados. Em vez de complexas cadeias if-else ou verifica√ß√µes de tipo, voc√™ escreve express√µes como `if (shape is Circle c)` para verificar o tipo e obter o objeto em uma √∫nica etapa.

```csharp
using System;

abstract class Forma {}

class Circulo : Forma
{
    public double Raio { get; }
    public Circulo(double raio) => Raio = raio;
}

class Retangulo : Forma
{
    public double Largura { get; }
    public double Altura { get; }
    public Retangulo(double largura, double altura) => (Largura, Altura) = (largura, altura);
}

class Program
{
    static void DescreverForma(Forma forma)
    {
        switch (forma)
        {
            case Circulo c:
                Console.WriteLine($"√â um c√≠rculo com raio {c.Raio}.");
                break;
            case Retangulo r:
                Console.WriteLine($"√â um ret√¢ngulo de {r.Largura} x {r.Altura}.");
                break;
            case null:
                Console.WriteLine("Forma inv√°lida.");
                break;
            default:
                Console.WriteLine("Forma desconhecida.");
                break;
        }
    }

    static void Main()
    {
        Forma minhaForma = new Circulo(5);
        DescreverForma(minhaForma); // Sa√≠da: √â um c√≠rculo com raio 5.
    }
}
```

- Explica√ß√£o r√°pida:

  - Criamos uma classe `Forma` e suas derivadas `Circulo` e `Retangulo`.
  - O m√©todo `DescreverForma` usa **correspond√™ncia de padr√µes** com `switch` para identificar o tipo de objeto e extrair propriedades.
  - Se `forma` for um `Circulo`, acessamos diretamente `Raio` sem precisar de convers√µes expl√≠citas.

- ‚úÖ **[Operadores nulos-condicionais](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-)** resolvem um problema comum: exce√ß√µes de refer√™ncia nula. O operador `?.` navega pelas hierarquias de objetos com seguran√ßa, interrompendo a avalia√ß√£o caso ela atinja um valor nulo. Escreva `customer?.Address?.City` em vez de verifica√ß√µes de valores nulos em cada etapa. Em conjunto com o operador de coalesc√™ncia de valores nulos `??`, voc√™ pode fornecer valores de fallback facilmente: `userName = user?.Name ?? "Guest"`.

```csharp
using System;

class Usuario
{
    public string Nome { get; set; }
}

class Program
{
    static void Main()
    {
        Usuario usuario = null;

        // Usa ?. para evitar exce√ß√£o de refer√™ncia nula
        string nomeUsuario = usuario?.Nome ?? "Convidado";

        Console.WriteLine($"Nome do usu√°rio: {nomeUsuario}");
    }
}
```

- Explica√ß√£o r√°pida:

  - `usuario?.Nome` evita uma exce√ß√£o se `usuario` for `null`. Se for nulo, a express√£o n√£o prossegue.
  - `??` fornece um **valor padr√£o** caso o operador nulo-condicional retorne `null`. No caso, `"Convidado"`.
  - Sem esse operador, precisar√≠amos de m√∫ltiplos `if` para evitar exce√ß√µes.

- ‚úÖ **[Express√µes de cole√ß√£o](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions)** tornam a cria√ß√£o e a inicializa√ß√£o de matrizes e listas mais concisas. Essa melhoria de sintaxe auxilia na cria√ß√£o e manipula√ß√£o de estruturas de dados. Podemos definir cole√ß√µes com menos c√≥digo, o que melhora a legibilidade em situa√ß√µes em que precisamos trabalhar com grupos de valores.

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Inicializando uma lista usando express√µes de cole√ß√£o
        List<int> numeros = [1, 2, 3, 4, 5];

        // Inicializando um array da mesma forma
        int[] valores = [10, 20, 30];

        Console.WriteLine($"Lista: {string.Join(", ", numeros)}");
        Console.WriteLine($"Array: {string.Join(", ", valores)}");
    }
}
```

- Explica√ß√£o r√°pida:

  - Usamos `List<int> numeros = [1, 2, 3, 4, 5];` para inicializar rapidamente uma lista sem precisar do `new List<int>()`.
  - O mesmo se aplica para arrays: `int[] valores = [10, 20, 30];`.
  - Esse recurso melhora a legibilidade e reduz c√≥digo desnecess√°rio, tornando a inicializa√ß√£o mais pr√°tica.

- ‚úÖ **[Membros com corpo de express√£o](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members)** nos permitem escrever m√©todos e propriedades simples em uma √∫nica linha. Em vez de `{ return x + y; }`, escreva `=> x + y`. Isso elimina o clich√™ e permite implementa√ß√µes mais limpas.

```csharp
using System;

class Calculadora
{
    // M√©todo de corpo de express√£o para somar dois n√∫meros
    public int Somar(int x, int y) => x + y;

    // Propriedade de corpo de express√£o para retornar uma mensagem
    public string Mensagem => "Ol√°, Adelino! Express√µes simplificam o c√≥digo.";
}

class Program
{
    static void Main()
    {
        Calculadora calc = new();
        Console.WriteLine($"Soma: {calc.Somar(5, 3)}");
        Console.WriteLine(calc.Mensagem);
    }
}
```

- Explica√ß√£o r√°pida:

  - O m√©todo `Somar` √© definido com `=>`, evitando o bloco `{ return x + y; }`.
  - A propriedade `Mensagem` usa `=>` para retornar um valor diretamente.

![](./imagens/700d177b-78eb-4e82-85b9-f03e0e935a6f_2200x1422.webp)

Muitos desses recursos n√£o s√£o apenas sintaxe conveniente, mas implementa√ß√µes integradas de **padr√µes de design** estabelecidos:

- Combinado com [yield](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/yield), as interfaces `IEnumerable`/`IEnumerator` implementam o **padr√£o Iterator**.
- Os eventos fornecem uma implementa√ß√£o do **padr√£o Observer**.
- Os delegados oferecem uma abordagem funcional aos **padr√µes de estrat√©gia e f√°brica**.
- Emparelhado com `IDisposable`, a instru√ß√£o cria um **padr√£o de gerenciamento de recursos** limpo.

Ao incorporar esses padr√µes diretamente na linguagem, o C# facilita a implementa√ß√£o de pr√°ticas de design robustas.

> üëâ _Saiba mais sobre como usar Padr√µes de Design com C# no **[meu livro](https://www.patreon.com/techworld_with_milan/shop/design-patterns-in-use-e-book-312304?utm_medium=clipboard_copy&utm_source=copyLink&utm_campaign=productshare_creator&utm_content=join_link)**._

## 3. O ecossistema .NET

Uma linguagem de programa√ß√£o n√£o existe isoladamente ‚Äî ela roda em uma plataforma e vem com ferramentas e bibliotecas. Um dos principais motivos para escolher C# para muitos de n√≥s n√£o s√£o apenas os recursos da linguagem, mas o ecossistema .NET que envolve o C#.

C# √© a linguagem principal do .NET e, como tal, desfruta de todos os benef√≠cios de um dos ecossistemas de desenvolvedores mais completos.

![.NET - Uma plataforma unificada](./imagens/2c73830e-c0d1-43ab-93d0-42d54227de22_1130x612.webp)

O desenvolvimento em C# est√° profundamente enraizado no ecossistema .NET, uma plataforma que a Microsoft fornece para a constru√ß√£o e execu√ß√£o de aplica√ß√µes. Historicamente, o **[.NET Framework](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet-framework)** foi a implementa√ß√£o original do .NET, voltada para o sistema operacional Windows. Ele oferecia um rico conjunto de bibliotecas e um ambiente de execu√ß√£o para a constru√ß√£o de diversas aplica√ß√µes, incluindo aplicativos de desktop para Windows, aplica√ß√µes web usando ASP.NET e servi√ßos web.

Em resposta √† necessidade de desenvolvimento multiplataforma, a Microsoft lan√ßou o **.NET Core** em 2016 ‚Äî esta implementa√ß√£o moderna do .NET √© [de c√≥digo aberto](https://dotnet.microsoft.com/en-us/platform/open-source) e projetada para rodar em Windows, macOS e Linux.

Desde ent√£o, a Microsoft unificou essas plataformas lan√ßando o .NET 5 em 2020 e vers√µes subsequentes.

Em um n√≠vel alto, atualmente o ecossistema .NET fornece os seguintes **[tempos de execu√ß√£o](https://learn.microsoft.com/en-us/dotnet/fundamentals/implementations)**:

- **.[NET 9](https://devblogs.microsoft.com/dotnet/announcing-dotnet-9/)** (ASP.NET Core, WPF, Windows Forms, Blazor). Uma plataforma unificadora para aplicativos de desktop, web, nuvem, dispositivos m√≥veis, jogos, IoT e IA.

- **[UWP](https://learn.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide)** [(Plataforma Universal do Windows)](https://learn.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide). Implementa o .NET para criar aplicativos e softwares Windows modernos e sens√≠veis ao toque para a Internet das Coisas (IoT).

- **[Mono](https://www.mono-project.com/)** A implementa√ß√£o .NET √© usada principalmente quando um tempo de execu√ß√£o pequeno √© necess√°rio. Aplicativos Xamarin com tempo de execu√ß√£o (agora sem suporte) est√£o dispon√≠veis para Android, macOS, iOS, tvOS e watchOS.

Todos os tempos de execu√ß√£o utilizam ferramentas e infraestrutura para compilar e executar c√≥digo. Isso inclui linguagens (C#, Visual Basic), compiladores (Roslyn), coleta de lixo e ferramentas de compila√ß√£o como MS Build ou Core CLR.

Al√©m das bibliotecas de tempo de execu√ß√£o e base, o .NET inclui **estruturas especializadas** para diferentes modelos de aplicativos:

- **Web:** [ASP.NET Core](https://dotnet.microsoft.com/en-us/apps/aspnet) para construir aplica√ß√µes web e APIs. Hoje, o ASP.NET Core √© um framework r√°pido e modular para construir APIs web, aplica√ß√µes web (usando MVC ou Razor Pages) e at√© aplica√ß√µes em tempo real (com [SignalR](https://dotnet.microsoft.com/en-us/apps/aspnet/signalr)).

- **[Blazor](https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor)** merece aten√ß√£o especial como uma das adi√ß√µes recentes mais revolucion√°rias ao ecossistema .NET. Ele permite que desenvolvedores **construam aplica√ß√µes web do lado do cliente usando C# em vez de JavaScript** usando a tecnologia WebAssembly. Isso permite que desenvolvedores C# usem suas habilidades existentes para desenvolvimento front-end, permitindo que criemos aplica√ß√µes C# full-stack sem alternar o contexto entre as linguagens.

- **√Årea de trabalho:** [Windows Presentation Foundation](https://learn.microsoft.com/en-us/dotnet/desktop/wpf/overview/?view=netdesktop-9.0) (WPF) e [Windows Forms](https://learn.microsoft.com/en-us/dotnet/desktop/winforms/overview/?view=netdesktop-9.0) para aplicativos de √°rea de trabalho do Windows (com suporte no .NET 6+ para Windows) e .[NET MAUI](https://dotnet.microsoft.com/en-us/apps/maui) (Interface de usu√°rio de aplicativo multiplataforma) para aplicativos cliente multiplataforma (a evolu√ß√£o do Xamarin Forms).

- **Mobile:** Xamarin (agora integrado como .NET para iOS/Android via **[MAUI](https://dotnet.microsoft.com/en-us/apps/maui)**) para aplicativos m√≥veis nativos.

- **Nuvem e servi√ßos:** Bibliotecas para criar microsservi√ßos, servi√ßos gRPC e integra√ß√µes de nuvem (especialmente com SDKs do Azure).

- **Desenvolvimento de jogos:** **[Unity](https://unity.com/)** usa uma vers√£o personalizada do runtime .NET Mono para scripts, e a Unreal Engine pode usar .NET por meio de plugins de terceiros. O Unity tem sido usado para desenvolver uma grande porcentagem de jogos para dispositivos m√≥veis (algumas estat√≠sticas indicam mais de 50% dos jogos para dispositivos m√≥veis e uma fra√ß√£o significativa dos jogos independentes para PC/console).

- **Ci√™ncia de dados e IA:** O .NET inclui [ML.NET](https://dotnet.microsoft.com/en-us/apps/ai/ml-dotnet) para aprendizado de m√°quina e pode interoperar com Python ou R para computa√ß√£o cient√≠fica. H√° at√© mesmo o [.NET para Apache Spark](https://learn.microsoft.com/en-us/azure/synapse-analytics/spark/spark-dotnet), permitindo que voc√™ escreva tarefas do Spark em C#.

- **IoT:** o .NET pode ser executado no Raspberry Pi e dispositivos similares (com o .NET 6+ suportando ARM64/ARM32), e h√° um [.NET NanoFramework](https://nanoframework.net/) menor para microcontroladores.

O ecossistema suporta diversas linguagens (C#, F#, VB), todas compiladas para IL e executadas no ambiente de execu√ß√£o .NET. Esse suporte a m√∫ltiplas linguagens permite que os desenvolvedores escolham diferentes paradigmas de programa√ß√£o (orientada a objetos, funcional, etc.) e, ao mesmo tempo, mantenham a mesma plataforma.

Isso √© algo que voc√™ raramente v√™ em qualquer outra plataforma.

> ** üìå Observa√ß√£o: o desenvolvimento da linguagem C# segue estas [diretrizes estrat√©gicas principais](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/strategy):**
>
> 1. Inovar amplamente em **colabora√ß√£o** com equipes do ecossistema .NET, enfatizando melhorias de produtividade, legibilidade e desempenho.
>
> 2. Mantenha a consist√™ncia com os **princ√≠pios** originais do C#, priorizando recursos intuitivos para desenvolvedores existentes.
>
> 3. Favore√ßa **melhorias** que beneficiem a maioria dos desenvolvedores em diversas cargas de trabalho e plataformas.
>
> 4. Mantenha uma forte **compatibilidade com vers√µes anteriores**, avaliando cuidadosamente e limitando mudan√ßas disruptivas.
>
> 5. Oriente a evolu√ß√£o da linguagem **abertamente**, considerando propostas e feedback da comunidade, mantendo a administra√ß√£o do design final.

## 4. Ferramentas

Uma das alegrias de trabalhar com C# para mim √© o **excelente suporte de ferramentas**.

### Microsoft Visual Studio

O **[Microsoft Visual Studio](https://visualstudio.microsoft.com/)** √© considerado h√° muito tempo um IDE de primeira linha (alguns o chamam de Mercedes no mundo dos IDEs). Ele possui recursos como o IntelliSense (completamento autom√°tico de c√≥digo e documenta√ß√£o), um excelente depurador, designers de interface do usu√°rio, ferramentas de teste integradas, criadores de perfil de desempenho e muito mais. Para muitos, os recursos de produtividade do Visual Studio s√£o um grande motivo para escolher C#/.NET em vez de outros ecossistemas.

[![Visual Studio 2022 Preview 4 j√° est√° dispon√≠vel! - Blog do Visual Studio](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F535b76fb-8f3a-4951-b558-0ffb42f17b85_1436x1072.png "Visual Studio 2022 Preview 4 j√° est√° dispon√≠vel! - Blog do Visual Studio Blog")](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F535b76fb-8f3a-4951-b558-0ffb42f17b85_1436x1072.png)

### Visual Studio Code

H√° tamb√©m o **[Visual Studio Code](https://code.visualstudio.com/)**(um editor leve e multiplataforma), que, com a extens√£o C# (agora aprimorada pelo [C# Dev Kit da Microsoft](https://learn.microsoft.com/en-us/visualstudio/subscriptions/vs-c-sharp-dev-kit)) e muitas [extens√µes](https://code.visualstudio.com/docs/configure/extensions/extension-marketplace), proporciona uma √≥tima experi√™ncia de desenvolvimento no Windows, Linux ou Mac. A Microsoft tamb√©m o desenvolveu e √© de c√≥digo aberto.

[![Interface do usu√°rio](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1eec024d-fc37-4ca3-a4e9-f95401f2dd24_1200x796.png "Usu√°rio interface")](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1eec024d-fc37-4ca3-a4e9-f95401f2dd24_1200x796.png)

### JetBrains Rider

**[JetBrains Rider](https://www.jetbrains.com/rider/)** √© um excelente IDE multiplataforma para C# para quem prefere ferramentas de terceiros. Ele tem √≥timo desempenho e funciona nas maiores solu√ß√µes C#. Tamb√©m √© gratuito para uso n√£o comercial.

[![Editor de texto Rider com conclus√£o de c√≥digo](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18202f38-7d9c-4152-b5db-5033f312f178_2480x1323.png "Editor de texto Rider com conclus√£o de c√≥digo conclus√£o")](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18202f38-7d9c-4152-b5db-5033f312f178_2480x1323.png)

### Ferramentas de constru√ß√£o

As **ferramentas de compila√ß√£o** ([compilador Roslyn](https://github.com/dotnet/roslyn) e [MSBuild](https://github.com/dotnet/msbuild)) funcionam em segundo plano para gerenciar depend√™ncias e compila√ß√£o. Configurar um novo projeto geralmente √© t√£o simples quanto alguns cliques ou comandos (`dotnet new console -o MyApp` criar√° um novo aplicativo de console por meio da CLI do .NET).

### CLI .NET

O **[.NET CLI](https://learn.microsoft.com/en-us/dotnet/core/tools/)** √© uma poderosa interface de linha de comando para criar, executar, testar e publicar aplicativos .NET, o que permite f√°cil automa√ß√£o e integra√ß√£o de CI/CD.

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe4254bc3-db29-4f44-9f52-f2c5d38bc8a5_1210 x622.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe4254bc3-db29-4f44-9f52-f2c5d38bc8a5_1210x622.png)

### Outras ferramentas

O C# tamb√©m se beneficia de recursos como **editar e continuar** durante a depura√ß√£o (modificar c√≥digo enquanto pausado em um ponto de interrup√ß√£o), **ferramentas de refatora√ß√£o** avan√ßadas (renomear s√≠mbolos, extrair m√©todos, etc.) e **[analisadores](https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview?view=vs-2022)** que detectam problemas comuns ou desvios de estilo conforme voc√™ digita.

Editores modernos podem at√© usar **[Analisadores Roslyn](https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview?view=vs-2022)** para sugerir corre√ß√µes (por exemplo, sugest√µes de "usar LINQ em vez deste loop" ou "remover convers√µes desnecess√°rias"). O n√≠vel de refinamento das ferramentas para desenvolvedores √© imbat√≠vel, melhorando significativamente a produtividade dos desenvolvedores.

A combina√ß√£o do design da linguagem C# com essas ferramentas poderosas cria um ambiente explicitamente focado na produtividade do desenvolvedor. A natureza fortemente tipada do C# permite que essas ferramentas forne√ßam recursos avan√ßados de an√°lise de c√≥digo, verifica√ß√£o de erros e refatora√ß√£o que seriam dif√≠ceis de implementar em linguagens mais din√¢micas.

## 5. Bibliotecas

A linguagem C# √© apenas uma parte do valor; as **[bibliotecas de classes .NET](https://learn.microsoft.com/en-us/dotnet/standard/class-library-overview)** fornecem muita funcionalidade.

A biblioteca padr√£o abrange tudo, desde cole√ß√µes at√© E/S de arquivos, redes, criptografia, threading, tratamento de XML/JSON e express√µes regulares. A Microsoft a disponibiliza prontamente e **[documenta](https://learn.microsoft.com/en-us/dotnet/)** a ela.

Isso significa que voc√™ pode fazer muita coisa sem precisar de bibliotecas de terceiros. Quando n√£o precisar de ajuda externa, voc√™ sempre pode usar o **[ecossistema de pacotes NuGet](https://www.nuget.org/)**.

Em 2025, o [NuGet.org](https://www.nuget.org/) teve um crescimento explosivo, com mais de 600 bilh√µes de downloads registrados e mais de 448 mil pacotes. Isso ilustra a forte depend√™ncia dos desenvolvedores .NET em bibliotecas compartilhadas.

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7644097b-ef83-499e-9464-cee485a9e821_815 x387.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7644097b-ef83-499e-9464-cee485a9e821_815x387.png)

Algumas bibliotecas NuGet populares s√£o:

- **[MediatR](https://github.com/jbogard/MediatR)** \- Implementa√ß√£o do padr√£o Mediator em .NET
- **[Polly](https://github.com/App-vNext/Polly)** \- Uma biblioteca de tratamento de falhas que permite a express√£o de pol√≠ticas como Retry e Circuit Breaker.
- **[Fluent Validation](https://github.com/JeremySkinner/FluentValidation)** \- Biblioteca de valida√ß√£o .NET para criar regras de valida√ß√£o fortemente tipadas.
- **[Benchmark.NET](https://github.com/dotnet/BenchmarkDotNet)** \- Biblioteca .NET para benchmarking.
- **[Refit](https://github.com/reactiveui/refit)** \- Transforma sua API REST em uma interface ativa.
- **[YARP](https://microsoft.github.io/reverse-proxy/)** \- Servidor proxy reverso.

## 6. Documenta√ß√£o

A documenta√ß√£o da Microsoft para C# e .NET (dispon√≠vel em **[learn.microsoft.com](https://learn.microsoft.com)**) √© geralmente excelente, com documentos conceituais, tutoriais e refer√™ncias completas de API.

Os documentos oficiais s√£o atualizados regularmente para novos recursos (por exemplo, quando o [C# 12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12) ou [13](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13) foi lan√ßado, os documentos estavam prontos, explicando os novos recursos.

Esta **documenta√ß√£o abrangente e atualizada** para todos os recursos √© extremamente valiosa, especialmente em compara√ß√£o a alguns ecossistemas abertos, onde voc√™ depende mais de wikis da comunidade ou postagens de blog dispersas.

Se voc√™ estiver interessado em explorar C#, aqui est√£o alguns recursos para voc√™ come√ßar:

- Instale o .NET a partir da **[p√°gina oficial de download](https://dotnet.microsoft.com/download)**
- Explore **[os tutoriais de C# do Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/csharp/)**
- Tente construir uma API web simples com **[ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/)**
- Para desenvolvimento de jogos, confira **[Unity Learn](https://learn.unity.com/)**
- Verifique a **[especifica√ß√£o oficial do C#](https://learn.microsoft.com/en-us/dotnet/csharp/specification/)**.
- **[Regras e conven√ß√µes de nomenclatura de identificadores C#](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names)** e as **[conven√ß√µes de codifica√ß√£o C#](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)**.

Outro ponto forte do C# √© que ele suporta **aprendizado progressivo**. Os desenvolvedores podem come√ßar a escrever c√≥digo aplic√°vel com apenas um pequeno subconjunto dos recursos da linguagem e expandir seus conhecimentos √† medida que se tornam mais proficientes. Essa curva de aprendizado gradual torna o C# acess√≠vel para iniciantes, mas ainda oferece a profundidade de que precisamos como desenvolvedores experientes.

Para quem busca se aprofundar, recomendo os seguintes livros:

- "**[C# em Profundidade](https://amzn.to/3Ersyji)**" por Jon Skeet para uma compreens√£o profunda da linguagem
- "**[ASP.NET Core em a√ß√£o](https://amzn.to/3Yb4iIW)**" por Andrew Lock para desenvolvimento web
- "**[Concorr√™ncia em C# Cookbook](https://amzn.to/42DgLGr)**" por Stephen Cleary para programa√ß√£o ass√≠ncrona avan√ßada

> ‚û° Ô∏è Confira aqui meus **recursos de aprendizagem recomendados para .NET e C#**:

[![](https://substackcdn.com/image/fetch/w_56,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fafd6c17b-1bdf-4b80-a7cc-bd216bbe8edb_653x653.png)Newsletter Tech World With Milan<br>Recursos de aprendizagem recomendados para C# e .NET em 2025.<br>A partir de 2025, o ecossistema .NET continua a prosperar, com o .NET 9 trazendo atualiza√ß√µes poderosas e o C# permanecendo como a principal escolha para desenvolvedores. Na recente pesquisa Stack Overflow Developer Survey 2024, .NET foi a biblioteca mais amada (fora da web‚Ä¶<br>Leia mais<br>H√° 2 meses ¬∑ 56 curtidas ¬∑ Dr. Milan Milanoviƒá](https://newsletter.techworld-with-milan.com/p/recommended-learning-resources-for?utm_source=substack&utm_campaign=post_embed&utm_medium=web)

Incluindo meu **[.NET Developer Roadmap](https://github.com/milanm/DotNet-Developer-Roadmap)** completo em um reposit√≥rio ativo do GitHub:

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F94f480f9-5c1c-4bb1-9a06-708b49067d8b_1610x2254.png)](https://github.com/milanm/DotNet-Developer-Roadmaphttps://github.com/milanm/DotNet-Developer-Roadmap)

[Roteiro para desenvolvedores .NET](https://github.com/milanm/DotNet-Developer-Roadmap)

## 7. Comunidade

C# e .NET desfrutam de uma **comunidade vibrante e forte suporte corporativo**. Este √© provavelmente um dos principais motivos pelos quais decidi me dedicar ao mundo do C# e .NET por todos esses anos.

No √¢mbito corporativo, a Microsoft investe pesado em C#/.NET. O fato de o C# ser de c√≥digo aberto significa que, mesmo fora da Microsoft, muitos colaboradores em todo o mundo ajudam a aprimor√°-lo.

O processo de design da linguagem √© p√∫blico ‚Äì voc√™ pode acompanh√°-lo no **[dotnet/csharplang GitHub](https://github.com/dotnet/csharplang)**, ler propostas, dar feedback ou at√© mesmo contribuir. Esse di√°logo aberto entre a equipe de design do C# e a comunidade foi destacado como um ponto forte: _‚ÄúH√° comunica√ß√£o e discuss√£o abertas entre a equipe de design da linguagem e a comunidade.‚Äù_

Isso significa que a linguagem tende a evoluir de maneiras que atendem √†s necessidades do mundo real, muitas vezes influenciadas por propostas da comunidade.

Aqui est√£o algumas das iniciativas e recursos comunit√°rios mais not√°veis:

- **[.NET Foundation](https://dotnetfoundation.org/)** ‚Äì Uma organiza√ß√£o independente e sem fins lucrativos que promove o desenvolvimento aberto e a colabora√ß√£o em todo o ecossistema .NET, incluindo C#. A Funda√ß√£o apoia centenas de projetos de c√≥digo aberto, ajuda a organizar encontros locais e online sobre .NET e fornece recursos para l√≠deres comunit√°rios e colaboradores.
- **[.NET Community Toolkit](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/)** ‚Äì Uma cole√ß√£o de auxiliares e APIs de c√≥digo aberto para todos os desenvolvedores .NET, mantida pela Microsoft e pela comunidade. Inclui ferramentas para desenvolvimento MVVM, cen√°rios de alto desempenho, diagn√≥sticos e muito mais.
- **[Reddit](https://www.reddit.com/r/dotnet/)**. O subreddit r/csharp √© um hub com mais de 200.000 membros. Ele oferece discuss√µes di√°rias, perguntas e respostas e um t√≥pico semanal "Pergunte o que quiser".
- **[Grupo C# Discord](https://discord.com/servers/c-143867839282020352)** ‚Äì Um servidor Discord com milhares de membros, oferecendo desafios, projetos colaborativos, grupos de aprendizagem e um ambiente de suporte para alunos e desenvolvedores C# de todos os n√≠veis.
- **[Encontros locais e globais](https://dotnetfoundation.org/community/.net-meetups)** \- A .NET Foundation apoia centenas de grupos locais de usu√°rios .NET e encontros em todo o mundo. Esses grupos organizam regularmente eventos, workshops e oportunidades de networking.
- **[Programa Microsoft MVP](https://mvp.microsoft.com/en-us/mvp)** \- A Microsoft reconhece colaboradores excepcionais da comunidade com o pr√™mio Microsoft MVP (Most Valuable Professional). Este programa re√∫ne defensores apaixonados de C# e .NET que compartilham sua expertise por meio de palestras, blogs e mentorias. Um MVP da Microsoft escreveu este texto üòä.
- **As confer√™ncias da Microsoft ([.NET Conf](https://www.dotnetconf.net/) e [Microsoft Build](https://build.microsoft.com/en-US/home))** s√£o eventos importantes que anunciam os avan√ßos mais recentes em .NET e C#. A comunidade se re√∫ne para aprender, fazer networking e compartilhar conhecimento. A .NET Conf, em particular, √© um evento global emblem√°tico organizado pela Microsoft e pela comunidade. Todo m√™s de novembro, novas edi√ß√µes de C# e .NET s√£o anunciadas.

Apesar do seu tamanho, a comunidade C# √© frequentemente descrita como acolhedora, apaixonada e pragm√°tica. Desenvolvedores frequentemente expressam entusiasmo genu√≠no pela linguagem e seu ecossistema, citando o prazer de escrever "**c√≥digo bonito**", a inova√ß√£o cont√≠nua e a sensa√ß√£o de produtividade que isso traz.

H√° uma **forte cultura de compartilhamento de conhecimento**, com muitos desenvolvedores contribuindo para o c√≥digo aberto, escrevendo tutoriais ou ajudando outros em f√≥runs e m√≠dias sociais.

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F643915f3-93a1-480b-9944-6d9adf1a8133_891x 576.jpeg)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F643915f3-93a1-480b-9944-6d9adf1a8133_891x576.jpeg)

Uma panor√¢mica com todos os MVPs da Microsoft no **MVP Summit 2025** deste ano

8. O concurso de popularidade

C# est√° consistentemente classificada entre as linguagens de programa√ß√£o mais utilizadas no mundo. Na [Pesquisa de Desenvolvedores do Stack Overflow 2024,](https://survey.stackoverflow.co/2024/), ficou em 8¬∫ lugar. Na categoria "Outros frameworks e bibliotecas" (https://survey.stackoverflow.co/2024/technology#most-popular-technologies-misc-tech), o .NET est√° em primeiro lugar.

[I](https://www.tiobe.com/tiobe-index/) atualmente (em 2025) ocupa o 5¬∫ lugar no √≠ndice TIOBE e [PyPL](https://pypl.github.io/PYPL.html). Em 2023, recebeu o pr√™mio "**[Linguagem de Programa√ß√£o do Ano](https://news.ycombinator.com/item?id=38899521)**".

[![√çndice TIOBE para C#](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Feca019e9-3033-44fa-a4dd-dc8074438e73_1339x438.png)](https://substackcdn.com/image/fetch/f_auto,q_a uto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Feca019e9-3033-44fa-a4dd-dc8074438e73_1339x438.png)

Do ponto de vista do **mercado de trabalho**, as habilidades em C# s√£o muito procuradas, principalmente em ambientes corporativos, desenvolvimento de jogos com Unity e desenvolvimento web. Os sites de empregos mostram que desenvolvedores em C# recebem sal√°rios competitivos, com sal√°rios medianos frequentemente superiores aos de muitas outras linguagens de programa√ß√£o. C# foi classificada em 4¬∫ lugar no DevJobsScanner "**[As 8 Linguagens de Programa√ß√£o Mais Demandadas em 2024](https://www.devjobsscanner.com/blog/top-8-most-demanded-programming-languages/)**", que analisou os √∫ltimos 21 meses e 12 milh√µes de vagas de desenvolvedor.

![Demanda de empregos em C# por m√™s em 2024](./imagens/019a9e2d-ff90-4fb7-9291-3111a5ff2ae5_1510x380.webp)

Vagas de emprego em C# de 1¬∫ de janeiro de 2023 a 30 de setembro de 2024 (Fonte: [DevJobsScanner](https://www.devjobsscanner.com/blog/top-8-most-demanded-programming-languages/))

Claro, precisamos falar sobre sal√°rios tamb√©m. Os melhores engenheiros C# ganham mais de **US$ 120 mil** nos EUA ([DevItJobs](https://devitjobs.com/salaries/dotNET/all/all/all)) e **US$ 110 mil** na Europa ([Dreamix](https://dreamix.eu/insights/c-sharp-dot-net-developer-salary-by-country/)). Algumas [fontes](https://rubyonremote.com/c-sharp-developer-salaries/), especialmente aquelas focadas em fun√ß√µes remotas ou de alta demanda, relatam sal√°rios m√©dios para desenvolvedores C# de at√© **US$ 156.430**, com os maiores sal√°rios chegando a **at√© US$ 301.100 por ano**.

Em [empresas l√≠deres](https://beincrypto.com/jobs/salary/c-sharp/), os sal√°rios de desenvolvedores C# podem ser ainda maiores. Por exemplo, a OKX oferece at√© **US$ 213.000 por ano** e a Limit Break oferece at√© **US$ 205.000** por ano para os melhores desenvolvedores C#. Com o C# sendo usado na web, na nuvem, em empresas e at√© mesmo em jogos, vale a pena se aprimorar e almejar estar entre os 10% melhores.

No entanto, popularidade n√£o √© tudo. O que importa mais √© se uma linguagem √© apropriada para suas necessidades espec√≠ficas, se voc√™ gosta de trabalhar com ela e se ela tem um futuro sustent√°vel. Em todas essas frentes, C# parece forte.

> **Observa√ß√£o**: _Leve em considera√ß√£o que h√° [cr√≠ticas ao √≠ndice TIOBE](https://nindalf.com/posts/stop-citing-tiobe/)._

9. C# vs outras linguagens

A imagem do C# n√£o estaria completa sem compar√°-lo aos principais concorrentes do mercado. Ent√£o, vamos ver como ele se sai.

### C# vs Java

Historicamente vistas como rivais, C# e Java s√£o hoje linguagens maduras, de alto desempenho e orientadas a objetos, amplamente utilizadas em backends corporativos. Embora ambas compartilhem uma sintaxe no estilo C e sejam usadas para construir uma ampla gama de aplica√ß√µes, elas apresentam caracter√≠sticas diferentes hoje.

C# possui recursos de linguagem mais modernos, como propriedades, sobrecarga de operadores, Consulta Integrada √† Linguagem (LINQ) e programa√ß√£o ass√≠ncrona com async/await. Isso pode resultar em **c√≥digo mais conciso e expressivo** do que a sintaxe mais verbosa do Java e diferentes abordagens para funcionalidades semelhantes.

Ambas possuem coleta de lixo e compila√ß√£o JIT, com caracter√≠sticas de desempenho semelhantes. Uma grande diferen√ßa √© o ecossistema: **Java tem um amplo ecossistema aberto e m√∫ltiplas implementa√ß√µes concorrentes** (OpenJDK, Oracle JDK), **enquanto C# tem um ecossistema mais unificado sob .NET** (embora Mono/Xamarin existissem, agora unificados com o n√∫cleo).

Ferramentas para C# (Visual Studio/Rider) vs. Java (IntelliJ/Eclipse) ‚Äì ambas boas, embora muitos considerem Visual Studio + ReSharper ou Rider extremamente produtivos. Java se destaca pelo princ√≠pio "escreva uma vez, execute em qualquer lugar" e domina algumas √°reas (como Android, que usa Java/Kotlin, embora agora o .NET MAUI tamb√©m possa ser usado em Android).

C# √© frequentemente visto como mais _elegante_ e moderno em design, j√° que aprendeu com os erros do Java e se mostrou mais disposto a evoluir rapidamente. H√° uma piada amig√°vel que diz que **C# √© o que Java seria se tivesse alma** ‚Äì subjetivo, mas mostra que muitos que usam ambos tendem a preferir a sensa√ß√£o e as conveni√™ncias do C#. Por outro lado, a simplicidade do Java (por n√£o ter muitos recursos da linguagem) pode beneficiar algumas equipes, reduzindo a complexidade.

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2a207f4a-93f1-47f2-b58b-1a51b08d0326_2132x 1025.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2a207f4a-93f1-47f2-b58b-1a51b08d0326_2132x1025.png)

C# vs Java no Google Trends (√∫ltimos 5 anos)

> ‚û° Ô∏è [Aprenda C# para desenvolvedores Java](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tips-for-java-developers).

### C# vs Python

Essas duas s√£o bem diferentes ‚Äì uma √© estaticamente tipada e compilada (para IL), a outra √© dinamicamente tipada e interpretada (com algumas exce√ß√µes). **Python** se destaca em scripts r√°pidos, sintaxe simples e no ecossistema de ci√™ncia de dados, por isso muitos a consideram a rainha das linguagens de programa√ß√£o hoje.

**C#** se destaca em engenharia de aplica√ß√£o abrangente, desempenho e ferramentas robustas. Em termos de desempenho, **[C# geralmente supera em muito Python](https://www.codeporting.com/blog/csharp_vs_python_a_look_at_performance_syntax_and_key_differences#:~:text=C,and%20its%20mature%20JIT) para tarefas que exigem muita CPU** (devido √† otimiza√ß√£o JIT e √† tipagem est√°tica, que permitem melhores otimiza√ß√µes).

C# tamb√©m permite controle de baixo n√≠vel (c√≥digo inseguro, Span<T>, etc.) para otimizar caminhos cr√≠ticos, enquanto Python frequentemente depende de extens√µes C para velocidade. Enquanto Python tem um REPL forte e uso interativo, C# historicamente n√£o tinha um REPL convencional (embora exista um como C# Interactive, e notebooks via .NET Interactive agora permitem interatividade semelhante).

Com instru√ß√µes de alto n√≠vel e suporte a scripts, C# ficou mais f√°cil, mas **Python ainda vence para scripts r√°pidos e √∫nicos** ou quando voc√™ precisa de uma vasta gama de bibliotecas cient√≠ficas. Dito isso, a lacuna est√° diminuindo ‚Äì por exemplo, voc√™ pode usar notebooks Jupyter com C# (via .NET Interactive) para explora√ß√£o de dados, e bibliotecas como a pilha SciSharp tentam portar parte do NumPy, etc., para .NET.

**Python √© frequentemente recomendado para iniciantes** devido √† sua sintaxe simples, enquanto C# pode exigir mais aprendizado devido ao seu sistema de tipos e recursos. No entanto, o C# moderno com ferramentas como o Visual Studio tamb√©m pode ser muito amig√°vel para iniciantes (o Intellisense e as verifica√ß√µes em tempo de compila√ß√£o o orientar√£o).

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe38c0112-0727-43d6-97fc-8c6d9d04d3ab_2132x992.png)](https://substackcdn.com/image/fetch/f_auto,q_a uto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe38c0112-0727-43d6-97fc-8c6d9d04d3ab_2132x992.png)

C# vs Python no Google Trends (√∫ltimos 5 anos)

> ‚û° Ô∏è [Aprenda C# para desenvolvedores Python](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tips-for-python-developers).

### C# vs F#

Uma coisa √© a mesma para ambos: eles rodam em .NET. **F#** √© uma linguagem funcional (tamb√©m multiparadigma, mas otimizada para FP) com infer√™ncia de tipos, imutabilidade por padr√£o e sintaxe simples. F# pode frequentemente expressar algoritmos ou modelos de dom√≠nio espec√≠ficos com mais clareza do que C# (por exemplo, uni√µes discriminadas e correspond√™ncia de padr√µes em adi√ß√µes de C# inspiradas em F#).

No entanto, **C# √© muito mais popular e possui mais bibliotecas** escritas explicitamente. Muitas empresas .NET usam C# para fins gerais e F# para tarefas espec√≠ficas em que ele se destaca (como mecanismos de c√°lculo complexos, l√≥gica espec√≠fica de dom√≠nio ou simplesmente por prefer√™ncia em servi√ßos menores).

A escolha entre C# e F# pode ser uma quest√£o de **prefer√™ncia de paradigma**: se voc√™ gosta de programa√ß√£o funcional, F# oferece isso com total interoperabilidade com .NET. Se voc√™ prefere ou precisa de uma **mistura de paradigmas e amplo suporte da comunidade**, C# √© uma escolha melhor.

Curiosamente, **recursos do F# migraram para o C#** (por exemplo, registros, correspond√™ncia de padr√µes), estreitando um pouco a lacuna. Mas o F# ainda tem vantagens como sintaxe lambda sucinta, infer√™ncia de tipos em todos os lugares (o `var` do C# √© uma infer√™ncia de tipos limitada) e recursos complexos de tipos (express√µes computacionais, etc.).

Alguns desenvolvedores recomendam usar F# para a l√≥gica do dom√≠nio principal (para corre√ß√£o e concis√£o) e C# para interface com frameworks (como UI, ou onde a POO faz mais sentido). N√£o h√° um vencedor; eles se complementam. A boa not√≠cia √© que voc√™ pode combin√°-los em um projeto, se necess√°rio.

[![F# vs C#](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faa7c857e-1805-41c5-9ba1-783c6a938c1f_373 x203.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faa7c857e-1805-41c5-9ba1-783c6a938c1f_373x203.png)

### C# vs JavaScript/TypeScript

JavaScript √© o rei do front-end web, mas o Node.js (JS) compete com o ASP.NET Core (C#) no back-end (e [o ASP.NET Core vence em benchmarks independentes](https://www.techempower.com/benchmarks/#section=data-r23)). A vantagem do Node √© sua linguagem unificada (JS) para front-end e back-end, bem como seu enorme ecossistema npm.

No entanto, muitos acham **C# com ASP.NET mais robusto para APIs grandes**, e o TypeScript (que adiciona tipos est√°ticos ao JS) essencialmente tenta trazer alguns dos benef√≠cios que o C# tem para o mundo JS.

Curiosamente, com **[Blazor](https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor)**, voc√™ pode at√© usar C# para escrever um front-end web (baseado em WebAssembly) em vez de JavaScript, o que √© um caminho promissor para quem deseja adotar C# full-stack. N√£o √© t√£o amplamente adotado quanto os frameworks JavaScript, mas √© um exemplo da abordagem inovadora do .NET (adotando o WebAssembly).

Em rela√ß√£o ao desempenho, **[C# no servidor tende a superar o Node.js em tarefas que exigem muita CPU](https://www.sitepoint.com/node-js-vs-net-core-what-to-choose/)** devido √† natureza single-thread do Node. No entanto, o Node lida muito bem com simultaneidade de E/S. C# tamb√©m lida muito bem com simultaneidade de E/S com async/await (e usando m√∫ltiplas threads ou threads de E/S), ent√£o √© mais uma quest√£o de prefer√™ncia e do ecossistema existente.

Para a experi√™ncia do desenvolvedor, depurar C# no Visual Studio √© geralmente mais f√°cil do que depurar Node.js devido a ferramentas melhores e tipagem est√°tica. O TypeScript nivelou o campo ao detectar erros para desenvolvedores de JS durante o tempo de compila√ß√£o (e est√° sendo desenvolvido pelo mesmo autor do C#).

No entanto, se algu√©m j√° for um desenvolvedor .NET/C#, ele pode preferir usar C# para o back-end e possivelmente o front-end (via Blazor) para evitar mudar o contexto para JavaScript.

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7ef9da46-9bab-4f73-9907-b8433bc338c6_2132x 1016.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7ef9da46-9bab-4f73-9907-b8433bc338c6_2132x1016.png)

C# vs JavaScript no Google Trends (√∫ltimos 5 anos)

> üëâ [Aprenda C# para desenvolvedores JavaScript](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tips-for-javascript-developers).

Aqui est√° a compara√ß√£o completa entre essas quatro l√≠nguas:

[![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd82b85d2-5672-45b5-b8b9- b3df1533569c_1674x938.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd82b85d2-5672-45b5-b8b9-b3df1533569c_1674x938.png)

Portanto, podemos dizer que C# se destaca ou se destaca em muitas √°reas em rela√ß√£o a outras linguagens. Pode n√£o ser t√£o minimalista ou din√¢mico quanto Python, mas oferece desempenho e estrutura para aplicativos grandes. Pode n√£o ser t√£o puramente funcional quanto F#, mas equilibra paradigmas e utiliza muito mais, ent√£o √© o melhor dos dois mundos.

> ** üìà Como o .NET se compara em desempenho a outras linguagens e tempos de execu√ß√£o?**
>
> _[A TechEmpower publica](https://www.techempower.com/) um conjunto de benchmarks de c√≥digo aberto que mede roteamento HTTP bruto, serializa√ß√£o JSON, leituras/grava√ß√µes em banco de dados e modelos HTML sob hardware e ferramentas uniformes. A [Rodada 23](https://www.techempower.com/benchmarks/#section=data-r23) (mar√ßo de 2025) √© a execu√ß√£o completa mais recente e apresenta hardware de 40 GbE mais r√°pido, portanto, as pontua√ß√µes n√£o s√£o diretamente compar√°veis √†s rodadas anteriores._
>
> _Se examinarmos os resultados e excluirmos alguns runtimes experimentais e raramente utilizados, vemos que o modelo leve de goroutine do Go lidera o campo principal, seguido de perto **pelo pipeline otimizado do .NET 8**. Os clusters Node/TypeScript, Kotlin e Java est√£o no meio, e os ecossistemas (Elixir, Python, Ruby, PHP, Swift) trocam velocidade absoluta por ergonomia do desenvolvedor e bibliotecas ricas._
>
> _Podemos ver aqui que **ASP.NET Core Minimal APIs no .NET 8/9**‚Äîpontua **87** nessa escala:_
>
> - _apenas ~10% atr√°s de Go/Fiber (pontua√ß√£o 100),_
>
> - _**‚âà3 √ó mais r√°pido** que o Node 20 + Fastify e o par JVM (Spring e Ktor),_
>
> - _**‚âà4 √ó mais r√°pido** que Elixir/Phoenix,_
>
> - _**‚âà7 √ó mais r√°pido** que Python/FastAPI,_
>
> - _**>20 √ó mais r√°pido** que Rails ou Laravel, e_
>
> - _**>40 √ó mais r√°pido** que Swift/Vapor._
>
> _Ent√£o, est√° claro que o .NET est√° quase no topo do jogo de desempenho porque o **Adaptive Server GC** (DATAS) aumenta ou diminui o heap em tempo real para reduzir o tempo de pausa durante rajadas; um compilador **JIT** em camadas, controlado por PGO, encurta o aquecimento e ent√£o otimiza novamente os caminhos mais ativos na produ√ß√£o; **APIs intr√≠nsecas ao vetor** agora t√™m como alvo AVX-10 e Arm SVE, permitindo que loops estreitos mastiguem dados de oito polegadas de largura em um √∫nico tique; **Native AOT** corta IL n√£o utilizado, **System.Text.Json** evita reflex√£o e copia menos bytes, ent√£o cada chamada REST aloca menos; e o roteador enxuto **Minimal API** introduzido no .NET 9 adiciona um aumento de taxa de transfer√™ncia de aproximadamente 15% em rela√ß√£o ao MVC no mesmo hardware._
>
> _Juntos, esses ajustes permitem que o CLR gaste menos tempo estacionando threads, copiando buffers ou compilando c√≥digo, e mais tempo atendendo seus usu√°rios._
>
> [![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fdbd8c2c5-5381-456f-899b-0b90bd72dee6_956 x681.png)](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fdbd8c2c5-5381-456f-899b-0b90bd72dee6_956x681.png)
>
> Compara√ß√£o de frameworks da Web (fonte: [TechEmpower Round-23](https://www.techempower.com/benchmarks/#section=data-r23))

## 10. O futuro do C#

C# √© uma linguagem que continua a evoluir rapidamente (j√° existe uma [vers√£o pr√©via do C# 14](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14)). A Microsoft lan√ßa novas vers√µes todos os anos e apresenta recursos novos e poderosos para desenvolvedores.

Vers√µes recentes introduziram inova√ß√µes como **[registros](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13)**, **[declara√ß√µes de n√≠vel superior](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/top-level-statements)**, **[tratamento aprimorado de strings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/improved-interpolated-strings)** e **[express√µes de cole√ß√£o concisas](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions)**. Cada vers√£o simplifica ainda mais as tarefas di√°rias e reduz o c√≥digo repetitivo, tornando o desenvolvimento mais r√°pido e f√°cil.

A Microsoft tem uma **estrat√©gia clara e proativa para evoluir a linguagem de programa√ß√£o C#.** A equipe C# colabora ativamente com as equipes respons√°veis pelas bibliotecas .NET, ferramentas para desenvolvedores e suporte √† carga de trabalho para introduzir novos recursos e aprimoramentos.

Um princ√≠pio fundamental que orienta essa evolu√ß√£o √© priorizar melhorias de linguagem e desempenho que beneficiar√£o a maioria dos desenvolvedores de C#, considerando uma **ampla gama de dom√≠nios nos quais a linguagem √© usada**.

H√° tamb√©m um **forte compromisso em manter a compatibilidade com vers√µes anteriores**, considerando a grande quantidade de c√≥digo C# em uso atualmente.

Dada a estrat√©gia proativa da Microsoft e o envolvimento cont√≠nuo da comunidade, **o futuro do C# parece muito promissor**.

## 11. Conclus√£o

Ent√£o, **por que C#**?

O desempenho, a legibilidade, a versatilidade e o ecossistema robusto do C# o tornam uma boa escolha para muitos cen√°rios de desenvolvimento atuais. De sua sintaxe concisa e expressiva a recursos poderosos como LINQ e async/await, **o C# ajuda os desenvolvedores a resolver problemas complexos com eleg√¢ncia e efici√™ncia.**

A linguagem **n√£o restringe voc√™ a um paradigma**. Dependendo das necessidades do seu projeto, voc√™ pode facilmente combinar programa√ß√£o orientada a objetos, programa√ß√£o funcional ou otimiza√ß√µes de baixo n√≠vel.

C# atinge o equil√≠brio perfeito entre pot√™ncia e acessibilidade. Ele permite que voc√™ **escreva c√≥digo simples e leg√≠vel para tarefas cotidianas, ao mesmo tempo em que oferece recursos avan√ßados quando necess√°rio**.

√Ä medida que suas habilidades progridem, **C# cresce com voc√™**, oferecendo recursos que ajudam a implementar padr√µes estabelecidos de forma correta e idiom√°tica. A linguagem **incentiva boas pr√°ticas sem for√ßar complexidade desnecess√°ria**, tornando-a adequada para iniciantes e desenvolvedores experientes.

Com o ecossistema .NET unificado, **voc√™ pode criar aplicativos multiplataforma com confian√ßa** ‚Äî desde web e mobile at√© desktop e servi√ßos em nuvem. Ferramentas avan√ßadas, bibliotecas abrangentes e uma grande comunidade (com o suporte da Microsoft) facilitam ainda mais o aprendizado e o desenvolvimento.

Claro, C# n√£o √© perfeito ‚Äî nenhuma linguagem √©. Pode parecer prolixo em compara√ß√£o com linguagens de script mais simples e n√£o √© ideal para tarefas de n√≠vel extremamente baixo. Mas √© **uma das linguagens mais produtivas e equilibradas dispon√≠veis para a maioria das aplica√ß√µes**, especialmente solu√ß√µes corporativas, servi√ßos web e desenvolvimento de jogos.

Para quem est√° em d√∫vida, **experimente C# no seu pr√≥ximo projeto**. Experimente seus recursos, explore o ecossistema. Voc√™ provavelmente descobrir√°, como eu, que ele atinge um ponto ideal que torna o desenvolvimento de software uma arte prazerosa.

C# me surpreende a cada nova vers√£o, por isso continua sendo minha linguagem por muitos anos.

## 12. B√îNUS: Uma breve hist√≥ria do C#

Toda linguagem tem uma hist√≥ria de origem. A hist√≥ria do [C#](<https://en.wikipedia.org/wiki/C_Sharp_(programming_language)>) come√ßa por volta de 2000, quando a Microsoft tentou criar uma nova linguagem para sua plataforma emergente .NET.

**Anders Hejlsberg**, um lend√°rio arquiteto de linguagens (conhecido por Turbo Pascal e Delphi, que hoje lidera o desenvolvimento do TypeScript), liderou o projeto do C#. O objetivo era construir uma linguagem **segura em termos de tipos e orientada a objetos** que combinasse o poder e a robustez do C++ com a produtividade mais simples e de alto n√≠vel de linguagens como o Visual Basic.

> üí° _O desenvolvimento inicial do C# foi chamado de "Cool" ou "Linguagem Orientada a Objetos semelhante ao C". No entanto, a Microsoft n√£o manteve o nome por quest√µes de marca registrada, mas ele realmente soa legal ;)._

Em ess√™ncia, os designers queriam _‚Äútudo de bom que h√° no Visual Basic e no C++‚Äù_ sem a complexidade e as armadilhas dessas linguagens. C# tamb√©m foi concebido como uma resposta ao Java ‚Äî a maneira da Microsoft de oferecer uma linguagem familiar de chaves para o novo mil√™nio, mas com suas melhorias e sem algumas das limita√ß√µes iniciais do Java (como as APIs corporativas inc√¥modas da √©poca).

Quando o C# 1.0 foi lan√ßado (junto com o .NET 1.0 em 2002), ele estava **firmemente enraizado na programa√ß√£o orientada a objetos (POO)**. Assim como o Java, exigia que todo o c√≥digo residisse dentro de classes. Apresentava coleta de lixo e um sistema de tipos robusto, eliminando a aritm√©tica de ponteiros para um c√≥digo mais seguro (embora um modo "inseguro" estivesse dispon√≠vel para programa√ß√£o de sistemas quando necess√°rio).

O _principal objetivo de design_ do C# era **simplicidade em vez de poder de baixo n√≠vel** ‚Äì voc√™ poderia abrir m√£o de um pouco do controle manual do C/C++. Ainda assim, voc√™ ganharia seguran√ßa de mem√≥ria (coleta de lixo) e desenvolvimento mais f√°cil.

Nas duas d√©cadas seguintes, **C# evoluiu** e adicionou recursos a quase todos os lan√ßamentos para permanecer moderno e relevante.

Aqui est√° um cronograma r√°pido de alguns marcos importantes:

- **C# 2.0 (2005)** ‚Äì Introduziu **gen√©ricos**, **iteradores** e classes parciais, melhorando significativamente a seguran√ßa de tipos e eliminando muitas tarefas repetitivas de codifica√ß√£o. (Os gen√©ricos em C# surgiram quase ao mesmo tempo que os gen√©ricos em Java, mas com uma diferen√ßa significativa que discutiremos mais tarde.)
- **C# 3.0 (2007)** ‚Äì Um lan√ßamento marcante que trouxe **express√µes lambda**, **LINQ (Consulta Integrada √† Linguagem)** e tipos an√¥nimos. Foi nessa √©poca que o C# come√ßou a adotar conceitos de programa√ß√£o funcional para complementar suas ra√≠zes de OO. O LINQ, em particular, foi um divisor de √°guas na manipula√ß√£o de dados em c√≥digo.
- **C# 5.0 (2012)** ‚Äì Adicionadas as palavras-chave `async`/`await` para **programa√ß√£o ass√≠ncrona**, simplificando drasticamente a concorr√™ncia e o c√≥digo de E/S. (Essa inova√ß√£o foi t√£o bem-sucedida que linguagens como Python e JavaScript adotaram mecanismos async/await semelhantes posteriormente.)
- **C# 6 e 7 (2015-2017)** ‚Äì Trouxe muitos ‚Äúa√ß√∫cares de sintaxe‚Äù e recursos de conveni√™ncia: **membros com corpo de express√£o**, **interpola√ß√£o de strings**, **express√µes nameof**, **tuplas** e **desconstru√ß√£o**, **correspond√™ncia de padr√µes**, etc. Esses recursos tornaram o c√≥digo C# mais conciso e expressivo, alcan√ßando ideias de linguagens funcionais e din√¢micas, mantendo a tipagem est√°tica.
- **C# 8 e 9 (2019-2020)** ‚Äì Introduzidos **tipos de refer√™ncia anul√°veis** (ajudando a mitigar o erro de bilh√µes de d√≥lares de refer√™ncias nulas), **registros** (para classes de dados imut√°veis), **declara√ß√µes de n√≠vel superior** (permitindo um estilo r√°pido semelhante a um script sem cerim√¥nia), **fun√ß√µes locais est√°ticas** e mais melhorias na correspond√™ncia de padr√µes. O .NET Core havia amadurecido nessa √©poca no **.NET 5**, unificando a plataforma em todos os sistemas operacionais.
- **C# 10 e 11 (2021-2022)** ‚Äì Melhorias incrementais cont√≠nuas (diretivas globais de `using`, estruturas de registro, recursos lambda aprimorados\*\*, etc.), mantendo o C# moderno.
- **C# 12 e 13 (2023-2024)** ‚Äì Inclui **construtores prim√°rios** para classes, **express√µes de cole√ß√£o**literais, **par√¢metros C# aprimorados**, **novo objeto de bloqueio** e outras melhorias para simplificar a codifica√ß√£o. √â claro que o C# n√£o est√° parado; ele √© continuamente refinado para se tornar mais poderoso e amig√°vel ao desenvolvedor.

Ao longo dessa jornada, o C# conseguiu **manter-se familiar** (o c√≥digo antigo ainda funciona, a sintaxe ainda _parece_ C#) enquanto **evolu√≠a** para incluir novos paradigmas. Ele se adapta √†s necessidades modernas de desenvolvimento, mas n√£o obriga voc√™ a abandonar o que j√° funciona.

Confira o **cronograma completo de desenvolvimento do C#/.NET**:

![Linha do tempo C#/.NET](./imagens/8635727b-58ed-4577-aef8-941e87fdedb7_2556x6001.webp)

---
