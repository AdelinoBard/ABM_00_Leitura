- **Cita√ß√£o**
    - **T√≠tulo**: Understanding Middlewares in ASP.NET Core - Everything you Need to Know!
    - **Autor**: Mukesh Murugan
    - **Fonte**: Code With Mukesh
    - **URL**: https://codewithmukesh.com/blog/middlewares-in-aspnet-core/
    - **Atualizado**: 26 de mar√ßo de 2025

---

# Understanding Middlewares in ASP.NET Core - Everything you Need to Know!

O ASP.NET Core segue um pipeline de processamento de solicita√ß√µes poderoso e flex√≠vel que permite aos desenvolvedores controlar como as solicita√ß√µes HTTP s√£o tratadas. No centro desse pipeline est√° o middleware ‚Äî uma s√©rie de componentes que processam solicita√ß√µes e respostas.

Cada solicita√ß√£o que chega a um aplicativo ASP.NET Core segue uma jornada bem definida pelo pipeline de solicita√ß√µes antes de gerar uma resposta. Esse pipeline √© constru√≠do usando middleware, um mecanismo poderoso que permite aos desenvolvedores inspecionar, modificar ou interromper solicita√ß√µes e respostas.

Neste artigo, exploraremos como o ASP.NET Core processa solicita√ß√µes de entrada, como o middleware funciona e como voc√™ pode criar seu pr√≥prio middleware para aprimorar os recursos da sua API Web.

> Este artigo faz parte do meu [curso .NET Web API Zero to Hero](/courses/dotnet-webapi-zero-to-hero/), onde abordo tudo o que voc√™ precisa saber para criar APIs eficientes e escal√°veis. Entender middleware ajudar√° voc√™ a controlar como as solicita√ß√µes s√£o processadas, gerenciar registros, lidar com a seguran√ßa e melhorar o desempenho. Isso garante que sua API esteja estruturada corretamente, com tratamento de erros, autentica√ß√£o e roteamento adequados.

Ao aprender middleware, voc√™ tamb√©m poder√° criar componentes personalizados para estender o ASP.NET Core e adicionar recursos espec√≠ficos √† sua aplica√ß√£o. Dominar esse conceito facilitar√° o trabalho com t√≥picos mais avan√ßados, como seguran√ßa, ajuste de desempenho e otimiza√ß√£o de APIs. Se voc√™ deseja construir APIs Web melhores, esta √© uma etapa essencial.

## O que s√£o middlewares no ASP.NET Core?
-------------------------------------

O middleware no ASP.NET Core √© um bloco de constru√ß√£o fundamental do pipeline de requisi√ß√µes. Ele atua como uma s√©rie de componentes de software que processam requisi√ß√µes e respostas HTTP. Cada componente de middleware pode inspecionar, modificar ou at√© mesmo encerrar uma requisi√ß√£o antes que ela atinja a l√≥gica central da aplica√ß√£o. Isso permite que os desenvolvedores lidem com tarefas como autentica√ß√£o, registro em log, tratamento de erros e modifica√ß√£o de respostas de forma estruturada.

Quando uma solicita√ß√£o entra na aplica√ß√£o, ela flui pelo pipeline do middleware na ordem em que √© registrada. Cada componente do middleware tem a op√ß√£o de processar a solicita√ß√£o, fazer altera√ß√µes nela ou pass√°-la para o pr√≥ximo middleware na fila. Se necess√°rio, o middleware tamb√©m pode gerar uma resposta imediatamente, efetivamente causando um curto-circuito no pipeline e impedindo a execu√ß√£o posterior de outros componentes do middleware.

O pipeline de middleware foi projetado para ser altamente flex√≠vel. Os desenvolvedores podem usar middleware integrado para tarefas comuns, como roteamento, autentica√ß√£o, registro em log e tratamento de exce√ß√µes, ou criar middleware personalizado, adaptado a necessidades espec√≠ficas. Como os componentes do middleware s√£o executados em sequ√™ncia, sua ordem no pipeline √© cr√≠tica. _Por exemplo, um middleware de autentica√ß√£o deve ser executado antes da autoriza√ß√£o, garantindo que a identidade do usu√°rio seja estabelecida antes da verifica√ß√£o das permiss√µes._

O ASP.NET Core facilita o registro de middleware no arquivo `Program.cs`, onde s√£o adicionados ao pipeline usando m√©todos como `app.Use`, `app.Run` e `app.Map`. Essa abordagem estruturada garante que as solicita√ß√µes sejam tratadas de forma consistente, ao mesmo tempo que oferece aos desenvolvedores a capacidade de personalizar e estender o pipeline conforme necess√°rio.

## Como funcionam os middlewares?
---------------------

Cada middleware no pipeline segue um padr√£o simples: recebe o `HttpContext`, realiza algum processamento e, em seguida, chama o pr√≥ximo middleware ou causa um curto-circuito no pipeline, gerando uma resposta imediatamente. Se o middleware causar um curto-circuito na solicita√ß√£o, ele impede a execu√ß√£o de outros componentes do middleware, permitindo otimiza√ß√µes como tratamento de erros ou retorno antecipado de respostas armazenadas em cache.

Ao estruturar o middleware corretamente, os desenvolvedores podem gerenciar com efici√™ncia o registro em log, a seguran√ßa, o tratamento de erros e a transforma√ß√£o de solicita√ß√µes, garantindo um fluxo de trabalho de processamento de solicita√ß√µes tranquilo e previs√≠vel em aplicativos ASP.NET Core.

Aqui est√° uma ilustra√ß√£o simples de como os middlewares funcionam em aplicativos ASP.NET Core.

![Middlewares explicados](../Leitura/imagens/middlewares-explained.BO30-Gyz_2uARXF.webp "Middlewares explicados")

* * *

## Ordem de execu√ß√£o do middleware
--------------------------

A ordem em que os componentes do middleware s√£o adicionados ao pipeline de solicita√ß√£o √© crucial no ASP.NET Core. O middleware √© executado sequencialmente na ordem em que √© registrado, o que significa que cada middleware pode modificar a solicita√ß√£o antes de pass√°-la para o pr√≥ximo componente ou modificar a resposta no caminho de volta.

Quando uma solicita√ß√£o entra no pipeline, ela flui por cada middleware **na ordem em que s√£o registrados**. Se um middleware chamar `await next()`, a solicita√ß√£o continua para o pr√≥ximo middleware. No caminho de volta, a resposta passa pelo middleware em **ordem reversa**, permitindo modifica√ß√µes antes de chegar ao cliente.

### **Exemplo de ordem de execu√ß√£o de middleware**

```c#
app.Use(async (context, next) =>
{
    Console.WriteLine("Middleware 1: Incoming request");
    await next();  // Pass control to the next middleware
    Console.WriteLine("Middleware 1: Outgoing response");
});

app.Use(async (context, next) =>
{
    Console.WriteLine("Middleware 2: Incoming request");
    await next();
    Console.WriteLine("Middleware 2: Outgoing response");
});

app.Run(async (context) =>
{
    Console.WriteLine("Middleware 3: Handling request and terminating pipeline");
    await context.Response.WriteAsync("Hello, world!");
});
```

### **Fluxo de execu√ß√£o esperado**

```bash
Middleware 1: Incoming request
Middleware 2: Incoming request
Middleware 3: Handling request and terminating pipeline
Middleware 2: Outgoing response
Middleware 1: Outgoing response
```

1. O cliente faz uma requisi√ß√£o.
2. O Middleware 1 √© acionado e exibe `"Middleware 1: Incoming request"`, depois passa o controle ao Middleware 2.
3. O Middleware 2 exibe `"Middleware 2: Incoming request"` e passa o controle ao Middleware 3.
4. O Middleware 3 processa a requisi√ß√£o e retorna `"Hello, world!"`.
5. O fluxo retorna para o Middleware 2, que exibe `"Middleware 2: Outgoing response"`.
6. O fluxo retorna para o Middleware 1, que exibe `"Middleware 1: Outgoing response"`.
7. A resposta final √© enviada ao cliente.

* O middleware √© executado na ordem em que √© adicionado em `Program.cs`.
* `app.Use()` permite que a solicita√ß√£o continue no pipeline e modifica as respostas no caminho de volta.
* `app.Run()` causa um curto-circuito no pipeline e impede a execu√ß√£o posterior do middleware.
* A ordem √© importante ‚Äî colocar o middleware de autentica√ß√£o antes do middleware de autoriza√ß√£o garante que os usu√°rios sejam autenticados antes de verificar as permiss√µes.

* * *

## Delegado de solicita√ß√£o e HttpContext - Conceitos principais
----------------------------------------------

Quando uma solicita√ß√£o chega a um aplicativo ASP.NET Core, ela passa por uma s√©rie de componentes de middleware antes de gerar uma resposta. No centro desse processo est√£o os **delegados de solicita√ß√£o** e o **HttpContext**.

Um **delegado de solicita√ß√£o** √© uma fun√ß√£o que manipula uma solicita√ß√£o HTTP e determina como ela deve ser processada. Ele pode modificar a solicita√ß√£o, gerar uma resposta ou passar o controle para o pr√≥ximo middleware no pipeline. Isso permite um controle mais preciso sobre o processamento da solicita√ß√£o.

Por outro lado, **HttpContext** fornece todos os detalhes sobre a solicita√ß√£o e resposta HTTP atuais. Ele cont√©m informa√ß√µes como cabe√ßalhos, par√¢metros de consulta, detalhes de autentica√ß√£o e configura√ß√µes de resposta, permitindo que os desenvolvedores interajam e manipulem o ciclo de vida da solicita√ß√£o de forma eficaz.

### **Request Delegate**

No ASP.NET Core, um **delegado de solicita√ß√£o** √© uma fun√ß√£o que processa solicita√ß√µes HTTP. √â o bloco de constru√ß√£o central do middleware e define como cada solicita√ß√£o √© tratada no pipeline. Delegados de solicita√ß√£o podem processar uma solicita√ß√£o e pass√°-la para o pr√≥ximo middleware ou gerar uma resposta diretamente.

H√° tr√™s maneiras de definir delegados de solicita√ß√£o:

1. **Middleware em linha (usando express√µes Lambda)**

```c#
app.Use(async (context, next) =>
{
    Console.WriteLine("Incoming request: " + context.Request.Path);
    await next();
    Console.WriteLine("Outgoing response: " + context.Response.StatusCode);
});
```
    
Aqui, `next()` garante que o pr√≥ximo middleware no pipeline seja executado.

2. **Usando `Run` para causar curto-circuito no pipeline**

```c#
app.Run(async context =>
{
    await context.Response.WriteAsync("Hello from the last middleware!");
});
```

`app.Run` n√£o chama `next()`, o que significa que ele causa um curto-circuito no pipeline de solicita√ß√£o.

3. **Usando classes de middleware**

```c#
public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        Console.WriteLine("Custom Middleware Executing...");
        await _next(context);
        Console.WriteLine("Custom Middleware Finished.");
    }
}
```
    
Registre-o em `Program.cs`:

```c#
app.UseMiddleware<CustomMiddleware>();
```

* * *

### **HttpContext**

`HttpContext` representa a solicita√ß√£o e a resposta HTTP atuais. Ele cont√©m tudo relacionado √† solicita√ß√£o que est√° sendo processada.

#### **Propriedades comumente usadas de `HttpContext`**

1. **Acessando dados de solicita√ß√£o**

```c#
string method = context.Request.Method;
string path = context.Request.Path;
string query = context.Request.QueryString.ToString();
```
    
2. **Leitura de cabe√ßalhos de solicita√ß√£o**

```c#
string userAgent = context.Request.Headers["User-Agent"];
```
    
3. **Manipulando Par√¢metros de Consulta**

```c#
string name = context.Request.Query["name"];
```
    
4. **Configurando dados de resposta**

```c#
context.Response.StatusCode = 200;
await context.Response.WriteAsync("Hello, World!");
```
    
5. **Verificando Autentica√ß√£o e Autoriza√ß√£o**

```c#
bool isAuthenticated = context.User.Identity.IsAuthenticated;
```

* * *

### **Como o Request Delegate e o HttpContext funcionam juntos**

Cada delegado de solicita√ß√£o recebe um `HttpContext`, processa-o e:

* Chama o pr√≥ximo middleware no pipeline (`await next();`)
* Retorna uma resposta imediatamente (`context.Response.WriteAsync("Hello!");`)

* * *

## Middlewares integrados
--------------------

O ASP.NET Core fornece diversos componentes de middleware integrados que gerenciam funcionalidades essenciais. Esses middlewares podem ser adicionados ao pipeline de requisi√ß√£o para habilitar diversos recursos, como autentica√ß√£o, roteamento, tratamento de exce√ß√µes e muito mais. Aqui est√£o alguns middlewares integrados comumente usados:

### **1. Middleware de Tratamento de Exce√ß√µes**

Este middleware captura exce√ß√µes n√£o tratadas e fornece um mecanismo centralizado para lidar com erros. Ele garante que os erros sejam registrados corretamente e pode retornar respostas de erro personalizadas.

```c#
app.UseExceptionHandler("/Home/Error");
```

### **2. Middleware de roteamento**

O roteamento determina como as solicita√ß√µes HTTP recebidas s√£o mapeadas para os endpoints apropriados no aplicativo. O middleware de roteamento √© crucial para definir rotas de API e a√ß√µes MVC.

```c#
app.UseRouting();
```

### **3. Middleware de Autentica√ß√£o e Autoriza√ß√£o**

Esses middlewares controlam a autentica√ß√£o do usu√°rio e o controle de acesso, garantindo que somente usu√°rios autorizados possam acessar determinados endpoints.

```c#
app.UseAuthentication();
app.UseAuthorization();
```

### **4. Middleware de arquivos est√°ticos**

Ele fornece conte√∫do est√°tico como HTML, CSS, JavaScript e imagens diretamente da pasta `wwwroot`.

```c#
app.UseStaticFiles();
```

### **5. Middleware CORS**

O middleware **Cross-Origin Resource Sharing** (CORS) controla como sua API lida com solicita√ß√µes de diferentes dom√≠nios.

```c#
app.UseCors(options =>
    options.WithOrigins("https://example.com")
           .AllowAnyMethod()
           .AllowAnyHeader());
```

### **6. Middleware de compress√£o de resposta**

Melhora o desempenho compactando as respostas antes de envi√°-las ao cliente, reduzindo o uso de largura de banda.

```c#
app.UseResponseCompression();
```

### **7. Middleware de Sess√£o**

Isso permite o gerenciamento de sess√µes armazenando dados de sess√£o do usu√°rio na mem√≥ria ou em armazenamentos distribu√≠dos como o Redis.

```c#
app.UseSession();
```

### **8. Middleware de redirecionamento HTTPS**

For√ßa todas as solicita√ß√µes a usar HTTPS, garantindo uma comunica√ß√£o segura.

```c#
app.UseHttpsRedirection();
```

### **9. Middleware de registro de solicita√ß√µes**

Registra solicita√ß√µes HTTP para fins de depura√ß√£o, auditoria ou monitoramento.

```c#
app.UseSerilogRequestLogging();
```

### **10. Middleware de ponto de extremidade**

A etapa final no processamento de solicita√ß√µes, este middleware corresponde √†s solicita√ß√µes recebidas aos seus respectivos controladores, p√°ginas Razor ou pontos de extremidade m√≠nimos da API.

```c#
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();
    endpoints.MapRazorPages();
});
```

* * *

## Middleware personalizado ‚Äì escrevendo o seu pr√≥prio
------------------------------------

Embora o ASP.NET Core forne√ßa v√°rios componentes de middleware integrados, h√° momentos em que √© necess√°rio implementar um middleware personalizado para atender a requisitos espec√≠ficos da aplica√ß√£o. O middleware personalizado permite modificar solicita√ß√µes e respostas, implementar logs, autentica√ß√£o, cache ou qualquer outra funcionalidade necess√°ria √† sua aplica√ß√£o.

### **Criando um Middleware Personalizado**

Um componente de middleware no ASP.NET Core deve:

1. Aceitar um `RequestDelegate` em seu construtor.
2. Implemente um m√©todo `Invoke` ou `InvokeAsync` que processe a solicita√ß√£o.

#### **Etapa 1: Criar uma classe de middleware**

```c#
public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Before the request is processed
        Console.WriteLine("Custom Middleware: Request Processing Started");

        await _next(context); // Call the next middleware

        // After the request is processed
        Console.WriteLine("Custom Middleware: Response Sent");
    }
}
```

#### **Etapa 2: Registrar Middleware no Pipeline**

Agora, voc√™ precisa adicionar esse middleware ao pipeline de solicita√ß√£o do aplicativo em `Program.cs`.

```c#
app.UseMiddleware<CustomMiddleware>();
```

Como alternativa, voc√™ pode registrar o middleware usando um m√©todo de extens√£o:

```c#
public static class CustomMiddlewareExtensions
{
    public static IApplicationBuilder UseCustomMiddleware(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<CustomMiddleware>();
    }
}
```

Agora, em `Program.cs`, basta usar:

```c#
app.UseCustomMiddleware();
```

### **Exemplo: Middleware personalizado para solicita√ß√µes de registro**

Aqui est√° um exemplo de um middleware que registra solicita√ß√µes recebidas:

```c#
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation($"Incoming Request: {context.Request.Method} {context.Request.Path}");

        await _next(context); // Continue the pipeline

        _logger.LogInformation($"Response Status Code: {context.Response.StatusCode}");
    }
}
```

Registre-o:

```c#
app.UseMiddleware<RequestLoggingMiddleware>();
```

## 2 maneiras comuns de criar middleware no ASP.NET Core
--------------------------------------------------

No ASP.NET Core, o middleware pode ser criado de diferentes maneiras, dependendo do n√≠vel de personaliza√ß√£o necess√°rio. As duas abordagens mais comuns s√£o o **Middleware Baseado em Delega√ß√£o de Solicita√ß√£o** e o **Middleware Baseado em Conven√ß√£o**.

### **Middleware baseado em `Request Delegate` (Delegado de solicita√ß√£o)**

Esta √© a maneira mais simples de criar middleware usando delegados de solicita√ß√£o em linha. Ela permite definir a l√≥gica do middleware diretamente no arquivo `Program.cs` sem criar uma classe separada.

```c#
app.Use(async (context, next) =>
{
    Console.WriteLine("Request Received: " + context.Request.Path);
    await next(); // Call the next middleware in the pipeline
    Console.WriteLine("Response Sent: " + context.Response.StatusCode);
});
```

Essa abordagem √© √∫til para pequenas e r√°pidas modifica√ß√µes no pipeline de solicita√ß√µes, como registrar ou modificar cabe√ßalhos de solicita√ß√£o. No entanto, para l√≥gicas mais complexas, recomenda-se o uso de middleware baseado em conven√ß√µes.

* * *

### **Middleware baseado em conven√ß√£o**

O middleware baseado em conven√ß√µes segue uma abordagem estruturada, definindo uma classe de middleware. Isso melhora a reutiliza√ß√£o, a manutenibilidade e a separa√ß√£o de responsabilidades.

```c#
public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        Console.WriteLine("Custom Middleware Executing...");
        await _next(context);
        Console.WriteLine("Custom Middleware Finished.");
    }
}
```

Aqui est√£o as conven√ß√µes necess√°rias,

* O construtor deve receber um par√¢metro `RequestDelegate`, que representa o pr√≥ximo middleware no pipeline.
* Isso permite que o middleware passe o controle para o pr√≥ximo componente, se necess√°rio.
* O m√©todo deve ser chamado Invoke ou InvokeAsync.
* Deve aceitar um par√¢metro HttpContext.
* Deve retornar uma Tarefa para dar suporte ao processamento ass√≠ncrono.

O middleware baseado em conven√ß√£o √© a abordagem preferida ao criar componentes de middleware reutiliz√°veis que lidam com registro, seguran√ßa, modifica√ß√µes de solicita√ß√£o ou transforma√ß√µes de resposta.

* * *

### Qual √© a abordagem correta?

Utilize **middleware baseado em delega√ß√£o de solicita√ß√µes** para tarefas simples, como registro de solicita√ß√µes ou configura√ß√£o de cabe√ßalhos. Quando voc√™ precisa de mais flexibilidade, o **middleware baseado em conven√ß√µes** √© a melhor escolha para l√≥gicas complexas que devem ser reutiliz√°veis em diferentes aplicativos.

## Curto-circuito no Pipeline
-----------------------------

Em alguns cen√°rios, pode ser necess√°rio interromper o prosseguimento da solicita√ß√£o no pipeline do middleware. Isso √© conhecido como **curto-circuito** no pipeline. Em vez de passar a solicita√ß√£o para o pr√≥ximo middleware usando `_next(context)`, voc√™ pode gerar uma resposta imediatamente. Essa t√©cnica √© √∫til para cen√°rios como modo de manuten√ß√£o, verifica√ß√µes de autentica√ß√£o, limita√ß√£o de taxa ou retorno antecipado de respostas armazenadas em cache para melhorar o desempenho.

```c#
public class MaintenanceMiddleware
{
    private readonly RequestDelegate _next;

    public MaintenanceMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.StatusCode = 503;
        await context.Response.WriteAsync("Service is under maintenance.");
    }
}
```

Registre este middleware antes que outros middlewares entrem em vigor:

```c#
app.UseMiddleware<MaintenanceMiddleware>();
```

## Melhores pr√°ticas para middleware em APIs da Web
-----------------------------------------

O middleware desempenha um papel crucial no processamento de solicita√ß√µes e respostas em APIs Web do ASP.NET Core. Projetar e estruturar o middleware corretamente garante melhor desempenho, manutenibilidade e seguran√ßa. Aqui est√£o algumas pr√°ticas recomendadas a serem seguidas ao trabalhar com middleware em APIs Web.

### **1. Mantenha o Middleware Leve**

O middleware deve se concentrar em uma √∫nica responsabilidade e evitar a execu√ß√£o de c√°lculos pesados ou tarefas de longa dura√ß√£o. Se for necess√°ria l√≥gica complexa, considere transferi-la para servi√ßos em segundo plano ou camadas de aplica√ß√£o separadas.

### **2. Ordene o Middleware Corretamente**

O middleware √© executado na ordem em que √© registrado, por isso √© importante posicion√°-lo estrategicamente. Por exemplo:

* O middleware de **manipula√ß√£o de exce√ß√µes** deve ser registrado primeiro para capturar todas as exce√ß√µes n√£o tratadas.
* **A autentica√ß√£o** deve vir antes da **autoriza√ß√£o** para garantir que o usu√°rio seja identificado antes das verifica√ß√µes de acesso.
* **O tratamento de arquivos est√°ticos** deve ser colocado antes dos middlewares de processamento de solicita√ß√µes para melhorar o desempenho.

### **3. Use middleware integrado sempre que poss√≠vel**

O ASP.NET Core fornece um rico conjunto de middleware integrado para tratamento de exce√ß√µes, autentica√ß√£o, CORS, compacta√ß√£o de resposta, etc. Em vez de escrever middleware personalizado do zero, prefira solu√ß√µes integradas para garantir confiabilidade e manutenibilidade.

```c#
app.UseExceptionHandler("/error");
app.UseAuthentication();
app.UseAuthorization();
app.UseRouting();
app.UseEndpoints(endpoints => endpoints.MapControllers());
```

### **4. Evite bloquear chamadas em middleware**

O middleware deve ser ass√≠ncrono para evitar o bloqueio do pipeline de solicita√ß√µes e a degrada√ß√£o do desempenho. Use `async` e `await` ao lidar com solicita√ß√µes.

**M√° pr√°tica (bloqueio de chamadas)**

```c#
public void Invoke(HttpContext context)
{
    var result = SomeLongRunningOperation().Result; // Blocks the thread
    context.Response.WriteAsync(result);
}
```

**Boas Pr√°ticas (Chamada Ass√≠ncrona)**

```c#
public async Task InvokeAsync(HttpContext context)
{
    var result = await SomeLongRunningOperation();
    await context.Response.WriteAsync(result);
}
```

### **5. Fa√ßa um curto-circuito no Pipeline quando necess√°rio**

Se uma solicita√ß√£o puder ser processada antecipadamente (como retornar uma resposta em cache ou processar o modo de manuten√ß√£o), fa√ßa um curto-circuito no pipeline para melhorar a efici√™ncia.

```c#
public async Task InvokeAsync(HttpContext context)
{
    if (context.Request.Path == "/maintenance")
    {
        context.Response.StatusCode = 503;
        await context.Response.WriteAsync("Service is under maintenance.");
        return; // Stop further middleware execution
    }

    await _next(context);
}
```

### **6. Use extens√µes de middleware para c√≥digo limpo**

Para manter `Program.cs` limpo e modular, encapsule o registro do middleware dentro dos m√©todos de extens√£o.

```c#
public static class CustomMiddlewareExtensions
{
    public static IApplicationBuilder UseCustomMiddleware(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<CustomMiddleware>();
    }
}
```

Agora, registre-o simplesmente como:

```c#
app.UseCustomMiddleware();
```

### **7. Execu√ß√£o do Middleware de Log para Depura√ß√£o**

Adicionar registro dentro do middleware ajuda a rastrear o processamento de solicita√ß√µes e diagnosticar problemas.

```c#
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoggingMiddleware> _logger;

    public LoggingMiddleware(RequestDelegate next, ILogger<LoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation($"Request: {context.Request.Method} {context.Request.Path}");
        await _next(context);
        _logger.LogInformation($"Response: {context.Response.StatusCode}");
    }
}
```

### **8. Evite o uso excessivo de middleware**

Nem tudo precisa ser um middleware. Se a l√≥gica for espec√≠fica para determinados controladores ou a√ß√µes, considere usar **filtros de a√ß√£o** ou **camadas de servi√ßo**. O middleware deve lidar com **quest√µes transversais**, como registro em log, autentica√ß√£o e tratamento de exce√ß√µes.

* * *

## Ordem de execu√ß√£o de middleware recomendada (B√îNUS)
----------------------------------------------

Veja como voc√™ deve organizar seus middlewares em seus aplicativos .NET para maximizar o desempenho!

```c#
var app = builder.Build();

app.UseExceptionHandler("/error");       // 1. Global Exception Handling
app.UseHttpsRedirection();               // 2. Enforce HTTPS
app.UseRouting();                        // 3. Routing Middleware
app.UseCors();                           // 4. Enable CORS (if needed)
app.UseAuthentication();                 // 5. Authenticate Users
app.UseAuthorization();                  // 6. Check Permissions
app.UseMiddleware<CustomMiddleware>();   // 7. Custom Middleware (e.g., Logging)
app.UseEndpoints(endpoints =>            // 8. Endpoint Execution
{
    endpoints.MapControllers();
});

app.Run();
```

### Por que esta ordem?

1. [Tratamento de exce√ß√µes](/blog/global-exception-handling-in-aspnet-core/) Primeiro: garante que todas as exce√ß√µes n√£o tratadas sejam capturadas antes de chegar ao cliente.
2. Redirecionamento HTTPS antecipado: redireciona HTTP para HTTPS o mais r√°pido poss√≠vel.
3. Roteamento antes da autentica√ß√£o: garante que as solicita√ß√µes sejam mapeadas antes das verifica√ß√µes de autentica√ß√£o.
4. Autentica√ß√£o antes da autoriza√ß√£o: um usu√°rio deve ser autenticado antes de verificar as permiss√µes.
5. Middleware personalizado antes dos endpoints: o registro, a limita√ß√£o de taxa ou a modifica√ß√£o de solicita√ß√µes devem ocorrer antes de atingir os controladores.

## **Resumo**
-----------

O middleware √© uma parte fundamental do pipeline de requisi√ß√µes do ASP.NET Core, permitindo que os desenvolvedores **lidem com quest√µes transversais**, como autentica√ß√£o, registro em log, tratamento de erros e transforma√ß√µes de requisi√ß√µes. Entender como o middleware funciona, a ordem correta de execu√ß√£o e as melhores pr√°ticas garante que suas APIs Web sejam eficientes, seguras e f√°ceis de manter.

Neste artigo, abordamos:

* **O que √© Middleware** e como ele processa solicita√ß√µes.
* **Middlewares integrados** no ASP.NET Core e suas fun√ß√µes.
* **Request Delegates e HttpContext**, que s√£o os blocos de constru√ß√£o do middleware.
* **Middleware personalizado** e como escrever o seu pr√≥prio para requisitos espec√≠ficos.
* **Curto-circuito no pipeline** para otimizar o desempenho quando necess√°rio.
* **Ordem de execu√ß√£o de middleware** e as melhores pr√°ticas recomendadas para estruturar seu pipeline.

Dominar middleware √© crucial para qualquer desenvolvedor ASP.NET Core. Seja para lidar com autentica√ß√£o, registro de erros ou otimiza√ß√µes de desempenho, o middleware oferece uma maneira limpa e modular de gerenciar solicita√ß√µes e respostas.

Este artigo faz parte do meu curso gratuito **.NET Web API Zero to Hero**, onde abordo conceitos essenciais para a constru√ß√£o de APIs Web de alta qualidade. Se voc√™ achou isso √∫til, n√£o deixe de **seguir meu curso** para obter conte√∫do mais aprofundado. Al√©m disso, sinta-se √† vontade para **compartilhar com seus colegas** que possam se beneficiar! üöÄ

Confira o curso completo aqui: [.NET Web API Zero to Hero](https://codewithmukesh.com/courses/dotnet-webapi-zero-to-hero/)
