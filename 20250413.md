- **Cita√ß√£o**
    - **T√≠tulo**: Melhores Pr√°ticas da API RESTful para Desenvolvedores .NET - Guia Completo
    - **Autor**: Mukesh Murugan
    - **Fonte**: Code With Mukesh
    - **URL**: https://codewithmukesh.com/blog/restful-api-best-practices-for-dotnet-developers/
    - **Atualizado**: 20 de mar√ßo de 2025

---

# Melhores pr√°ticas de API RESTful para desenvolvedores .NET - Guia completo para arquitetura RESTful e melhores pr√°ticas

Bem-vindo ao primeiro artigo do curso GRATUITO **‚Äú.NET Web API Zero to Hero‚Äù**! Se voc√™ √© um desenvolvedor .NET que busca criar APIs web modernas, escal√°veis e sustent√°veis, est√° no lugar certo. Neste artigo, vamos nos aprofundar nos princ√≠pios b√°sicos do REST (Representational State Transfer) e como voc√™ pode aplic√°-los para projetar APIs RESTful usando .NET.

Queria focar neste t√≥pico primeiro porque ainda vejo muitos desenvolvedores que n√£o aderem aos princ√≠pios REST e acabam construindo endpoints de API muito dif√≠ceis de ler/manter. Ao final deste artigo, voc√™ ter√° uma s√≥lida compreens√£o da arquitetura RESTful, das melhores pr√°ticas e de como implement√°-las em seus projetos .NET. Vamos come√ßar!

## **Introdu√ß√£o ao REST e sua import√¢ncia**

### O que √© REST?

REST, ou **Transfer√™ncia de Estado Representacional**, √© um estilo de arquitetura para projetar aplica√ß√µes em rede. REST se baseia em um protocolo de comunica√ß√£o cliente-servidor sem estado ‚Äî quase sempre HTTP. Ele foi projetado para ser simples, escal√°vel e f√°cil de usar.

### Por que REST √© popular?

O REST ganhou ampla ado√ß√£o devido √† sua simplicidade e flexibilidade. Ao contr√°rio do SOAP (Simple Object Access Protocol), que depende de XML e possui uma estrutura r√≠gida, o REST utiliza m√©todos HTTP padr√£o e pode retornar dados em diversos formatos, como JSON, XML ou at√© mesmo HTML. Isso torna as APIs RESTful mais f√°ceis de implementar e consumir.

### Benef√≠cios das APIs RESTful para desenvolvedores .NET

* **Escalabilidade**: APIs RESTful n√£o t√™m estado, o que significa que cada solicita√ß√£o √© independente. Isso as torna altamente escal√°veis.
* **Simplicidade**: REST usa m√©todos HTTP padr√£o (GET, POST, PUT, DELETE) e URIs simples, tornando-o f√°cil de entender e usar.
* **Flexibilidade**: APIs RESTful podem retornar dados em v√°rios formatos, como JSON ou XML, dependendo das necessidades do cliente.
* **Separa√ß√£o de Preocupa√ß√µes**: REST separa o cliente (front-end) do servidor (back-end), permitindo que ambos evoluam independentemente.

## **Aprofundamento nos princ√≠pios REST**

Para criar uma API RESTful de verdade, voc√™ precisa seguir estes princ√≠pios b√°sicos:

### **Arquitetura Cliente-Servidor**

A arquitetura cliente-servidor √© um princ√≠pio fundamental do REST. Neste modelo:

* O **cliente** (por exemplo, um navegador da web ou aplicativo m√≥vel) √© respons√°vel pela interface do usu√°rio e pela experi√™ncia do usu√°rio.
* O **servidor** (por exemplo, uma API Web .NET) lida com armazenamento de dados, l√≥gica de neg√≥cios e gerenciamento de recursos.

Essa separa√ß√£o de responsabilidades permite que o cliente e o servidor evoluam de forma independente. Por exemplo, voc√™ pode atualizar a l√≥gica do lado do servidor sem afetar o cliente ou desenvolver um novo cliente (como um aplicativo m√≥vel) sem alterar o servidor.

**Exemplo:** Imagine que voc√™ est√° criando um aplicativo de e-commerce. O cliente (um aplicativo m√≥vel) exibe os detalhes do produto ao usu√°rio, enquanto o servidor (uma API Web .NET) gerencia o banco de dados de produtos e processa os pedidos.

### **Apatridia**

A aus√™ncia de estado √© outro princ√≠pio fundamental do REST. Em um sistema sem estado:

* O servidor n√£o armazena nenhum contexto de cliente entre solicita√ß√µes.
* Cada solicita√ß√£o do cliente deve conter todas as informa√ß√µes necess√°rias para process√°-la.

**Exemplo:** Se um cliente quiser recuperar uma lista de usu√°rios, ele deve incluir quaisquer tokens de autentica√ß√£o ou par√¢metros de consulta necess√°rios na solicita√ß√£o. O servidor processa a solicita√ß√£o e retorna a resposta apropriada sem armazenar nenhum dado espec√≠fico do cliente.

**Benef√≠cios da apatridia:**
* **Escalabilidade**: Como o servidor n√£o mant√©m o estado da sess√£o, ele pode lidar com um grande n√∫mero de solicita√ß√µes com efici√™ncia.
* **Simplicidade**: Sistemas sem estado s√£o mais f√°ceis de implementar e depurar porque cada solicita√ß√£o √© independente.

### **Interface uniforme**

A interface uniforme √© um dos princ√≠pios mais importantes do REST. Ela garante que a API seja consistente e previs√≠vel, facilitando sua compreens√£o e utiliza√ß√£o pelos desenvolvedores.

A interface uniforme √© alcan√ßada por meio de quatro restri√ß√µes:

1. **Baseado em recursos**: Tudo em uma API RESTful √© um recurso, como usu√°rios, produtos ou pedidos. Cada recurso √© identificado por um URI (Uniform Resource Identifier) exclusivo.
    * Exemplo: `/api/users` representa uma cole√ß√£o de usu√°rios.

2. **M√©todos HTTP**: APIs RESTful usam m√©todos HTTP padr√£o para executar a√ß√µes em recursos:
    * **GET**: Recupera um recurso ou lista de recursos.
    * **POST**: Crie um novo recurso.
    * **PUT**: Atualiza um recurso existente (substitui-o completamente).
    * **PATCH**: Atualiza parcialmente um recurso.
    * **DELETE**: Exclui um recurso.

3. **Representa√ß√£o**: Os recursos podem ter diversas representa√ß√µes, como JSON, XML ou HTML. O cliente e o servidor concordam sobre o formato a ser usado para comunica√ß√£o.
    * Exemplo: Um cliente pode solicitar dados no formato JSON definindo o cabe√ßalho `Accept` como `application/json`.

4. **Mensagens autodescritivas**: Cada mensagem em uma API RESTful inclui informa√ß√µes suficientes para descrever como process√°-la.
    * Exemplo: O cabe√ßalho `Content-Type` especifica o formato da resposta e o c√≥digo de status HTTP indica o resultado da solicita√ß√£o.

### **Cache√°vel**

APIs RESTful oferecem suporte ao armazenamento em cache para melhorar o desempenho. O servidor pode indicar se uma resposta pode ser armazenada em cache e por quanto tempo.

**Exemplo:** Se um cliente solicitar uma lista de produtos, o servidor pode incluir um cabe√ßalho `Cache-Control` na resposta para especificar por quanto tempo o cliente pode armazenar os dados em cache. 

**Benef√≠cios do cache:**
* **Desempenho aprimorado**: o cache reduz o n√∫mero de solicita√ß√µes ao servidor, melhorando os tempos de resposta.
* **Carga reduzida do servidor**: o cache reduz a carga no servidor, tornando-o mais escal√°vel.

### **Sistema em camadas**

REST permite que voc√™ use uma arquitetura em camadas onde o cliente n√£o precisa saber se est√° se comunicando diretamente com o servidor ou por meio de um intermedi√°rio (como um balanceador de carga ou proxy).

**Exemplo:** Um cliente envia uma solicita√ß√£o a uma API RESTful, que √© roteada por meio de um balanceador de carga para um dos v√°rios servidores de back-end. O cliente desconhece a arquitetura subjacente.

**Benef√≠cios de um sistema em camadas:**
* **Escalabilidade**: Camadas podem ser adicionadas ou removidas sem afetar o cliente.
* **Seguran√ßa**: Intermedi√°rios podem fornecer seguran√ßa adicional, como termina√ß√£o SSL.

## **Melhores pr√°ticas de API RESTful para desenvolvedores .NET**

Esta √© a minha se√ß√£o favorita de todo este artigo. Concentre-se em acertar isso no seu pr√≥ximo projeto de API Web.

Aqui est√£o algumas pr√°ticas recomendadas a serem seguidas ao criar APIs RESTful no .NET.

### **Use substantivos para URIs de recursos**

URIs devem representar recursos, n√£o a√ß√µes. Use substantivos em vez de verbos.

**Exemplo:**
* Bom: `/api/users`
* Ruim: `/api/getUsers`

### **Use substantivos no plural para URIs de recursos**

Ao projetar APIs RESTful, os nomes dos recursos devem ser plurais para indicar cole√ß√µes de entidades. Isso mant√©m a API consistente e alinhada aos princ√≠pios REST.

**Exemplo:**
* **Bom:** `/api/users`
* **Ruim:** `/api/user`

Mesmo quando se trata de uma √∫nica entidade, o plural permanece intuitivo:

* **Buscando todos os usu√°rios:** `GET /api/users`
* **Buscando um √∫nico usu√°rio:** `GET /api/users/{id}`

Essa abordagem melhora a clareza e mant√©m a consist√™ncia entre os pontos finais.

### **Use aninhamento em pontos de extremidade para mostrar relacionamentos**

Quando os recursos t√™m um relacionamento hier√°rquico, use rotas aninhadas para refletir sua estrutura. Isso melhora a clareza e torna a API mais intuitiva.

**Exemplo:**
* **Bom:** `/api/users/{userId}/orders` (Obter todos os pedidos de um usu√°rio)
* **Ruim:** `/api/orders?userId={userId}`

Para entidades espec√≠ficas:

* **Bom:** `/api/users/{userId}/orders/{orderId}` (Obter um pedido espec√≠fico para um usu√°rio)
* **Ruim:** `/api/orders/{orderId}`

Use o aninhamento apenas quando o recurso filho for fortemente dependente do pai. Se ele puder existir de forma independente, uma estrutura plana √© prefer√≠vel.

### **Saiba quando usar par√¢metros de caminho versus par√¢metros de consulta**

A escolha entre par√¢metros de caminho e par√¢metros de consulta depende do tipo de dados que est√£o sendo passados e da inten√ß√£o da solicita√ß√£o.

#### **Par√¢metros de caminho** (para identificar recursos)

Use par√¢metros de caminho ao especificar um recurso ou entidade na hierarquia.

**Exemplo:**
* **Bom:** `/api/users/{userId}` (Buscar um usu√°rio espec√≠fico)
* **Ruim:** `/api/users?userId={userId}`

#### **Par√¢metros de consulta** (para filtragem, classifica√ß√£o e pagina√ß√£o)

Use par√¢metros de consulta para par√¢metros opcionais que refinam uma solicita√ß√£o, mas n√£o alteram a identidade do recurso.

**Exemplo:**
* **Bom:** `/api/users?role=admin&sort=asc&page=2`
* **Ruim:** `/api/users/admin/sort/asc/page/2`

Seguir essa abordagem mant√©m as APIs limpas, previs√≠veis e f√°ceis de usar.

### **Use o cache para melhorar o desempenho da API**

O cache ajuda a reduzir a carga do servidor e o tempo de resposta, armazenando dados acessados com frequ√™ncia. Implementar estrat√©gias de cache adequadas pode melhorar significativamente o desempenho da API.

#### **Tipos de cache em APIs REST:**

1. **Cache do lado do cliente**
* Use `Cache-Control` e os cabe√ßalhos `ETag` para permitir que navegadores e clientes armazenem em cache as respostas.
* **Exemplo:**
```
Cache-Control: max-age=3600, public
ETag: "abc123"
```
* Os clientes podem usar `If-None-Match` com `ETag` para evitar transfer√™ncia desnecess√°ria de dados.

2. **Cache do lado do servidor**
* Armazene respostas acessadas com frequ√™ncia na mem√≥ria (por exemplo, Redis, cache na mem√≥ria).
* Ideal para reduzir consultas repetidas ao banco de dados.
* Saiba mais sobre [Cache InMemory](/blog/in-memory-caching-in-aspnet-core/), [Cache Distribu√≠do](/blog/distributed-caching-in-aspnet-core-with-redis/) e [Cache de Resposta](/blog/caching-with-mediatr-in-aspnet-core/).

3. **Cache CDN**
* Use Redes de Distribui√ß√£o de Conte√∫do (CDNs) para armazenar em cache respostas est√°ticas mais pr√≥ximas dos usu√°rios para acesso mais r√°pido.
* √ìtimo para APIs de grande escala com alto tr√°fego.

4. **Cache de consulta de banco de dados**
* Armazene em cache os resultados de consultas caras ao banco de dados para melhorar o desempenho.
* Esteja atento √†s estrat√©gias de invalida√ß√£o de cache para garantir a atualiza√ß√£o dos dados.

Ao implementar o cache corretamente, voc√™ pode melhorar significativamente a escalabilidade e a capacidade de resposta da sua API.

### **Use m√©todos HTTP corretamente em APIs RESTful**

Ao projetar uma API RESTful, escolher o m√©todo HTTP correto √© crucial para clareza, manutenibilidade e ader√™ncia aos princ√≠pios REST. Veja aqui uma an√°lise dos m√©todos mais utilizados:

#### **1. GET (Recuperar um Recurso)**

* Usado para buscar dados do servidor.
* Deve ser **idempotente**, o que significa que v√°rias solicita√ß√µes devem retornar o mesmo resultado sem modificar os dados.
* Exemplo:
    ```
    GET /api/users       ‚Üí Retrieves a list of users
    GET /api/users/1     ‚Üí Retrieves details of a specific user (ID = 1)
    ```

#### **2. POST (Criar um novo recurso)**

* Usado para criar um novo recurso no servidor.
* **N√£o idempotente** ‚Äì se voc√™ enviar a mesma solicita√ß√£o v√°rias vezes, v√°rios recursos ser√£o criados.
* Retorna `201 Created` em caso de sucesso, juntamente com um cabe√ßalho `Location` apontando para o novo recurso. 
* Exemplo:
    ```
    POST /api/users
    Body: { "name": "John Doe" }
    ```
    Resposta:
    ```
    201 Created
    Location: /api/users/3
    ```
    
#### **3. PUT (Atualizar um Recurso Existente - Substitui√ß√£o Completa)**

* Usado para atualizar um **recurso inteiro** substituindo-o por novos dados.
* **Idempotente** ‚Äì enviar a mesma solicita√ß√£o v√°rias vezes deve resultar no mesmo estado no servidor.
* Se o recurso n√£o existir, algumas implementa√ß√µes criam um novo recurso (comportamento `Upsert`).
* Exemplo:
    ```
    PUT /api/users/1
    Body: { "id": 1, "name": "John Smith" }
    ```    
    * Se existir, ele substitui todo o objeto do usu√°rio pelos novos dados.`id=1`
    * Se n√£o existir, algumas APIs podem criar um novo usu√°rio.`id=1`

#### **4. PATCH (Atualiza√ß√£o Parcial - Modificar Campos Espec√≠ficos)**

* Usado para atualizar **apenas campos espec√≠ficos** de um recurso, em vez de substituir o objeto inteiro.
* **N√£o necessariamente idempotente** ‚Äì dependendo da implementa√ß√£o, enviar a mesma solicita√ß√£o v√°rias vezes pode ter efeitos diferentes.
* Exemplo:
    ```
    PATCH /api/users/1
    Body: { "name": "John Smith" }
    ```
    Isso atualiza apenas o campo `name` do usu√°rio sem modificar outras propriedades.

#### **5. DELETE (Remover um Recurso)**

* Usado para excluir um recurso do servidor.
* Deve ser **idempotente** ‚Äì se o recurso j√° tiver sido exclu√≠do, as solicita√ß√µes DELETE subsequentes devem retornar `204 No Content` ou `404 Not Found`.
* Exemplo:
```
DELETE /api/users/1
```
Resposta:
```
204 No Content
```

<br> --------------------------------------------------------------------------

> **PUT vs. PATCH ‚Äì Qual √© a diferen√ßa?**

`PUT` e `PATCH` (ambos) s√£o usados para atualizar recursos, mas atendem a prop√≥sitos diferentes.

| Recurso | PUT (Atualiza√ß√£o completa) | PATCH (Atualiza√ß√£o parcial) |
| --- | --- | --- |
| **Objetivo** | Substitui todo o recurso | Modifica campos espec√≠ficos de um recurso |
| **Corpo da solicita√ß√£o** | Deve conter o objeto inteiro, incluindo campos inalterados | Cont√©m apenas os campos que precisam ser atualizados |
| **Idempotente?** | Sim, v√°rias solicita√ß√µes id√™nticas resultam no mesmo estado final | N√£o necessariamente, pois solicita√ß√µes PATCH repetidas podem alterar o recurso de forma diferente |
| **Caso de uso** | Quando voc√™ deseja garantir que todos os campos sejam atualizados | Quando apenas alguns campos precisam ser alterados |
| **Exemplo de solicita√ß√£o** | `{ "id": 1, "name": "John Smith", "age": 30 }` | `{ "name": "John Smith" }` |

### **Qual voc√™ deve usar?**

* Use **PUT** ao atualizar **todos os campos** de um recurso, garantindo consist√™ncia.
* Use **PATCH** ao **modificar apenas campos espec√≠ficos** para evitar atualiza√ß√µes desnecess√°rias.

<br> --------------------------------------------------------------------------

### **Use c√≥digos de status HTTP**

Retorne o c√≥digo de status HTTP apropriado para indicar o resultado da solicita√ß√£o:

* `200 OK`: Sucesso.
* `201 Created`: Recurso criado com sucesso.
* `400 Bad Request`: Entrada inv√°lida.
* `404 Not Found`: Recurso n√£o encontrado.
* `500 Internal Server Error`: erro do servidor.

**Exemplo:**
```
return NotFound(); // Returns 404
return Ok(user);  // Returns 200
```

### **Vers√£o da sua API**

Sempre versione sua API para evitar altera√ß√µes significativas em clientes existentes.

**Exemplo:**
* `/api/v1/users`
* `/api/v2/users`

### **Use JSON para troca de dados**

JSON √© o formato mais utilizado para APIs REST. √â leve e f√°cil de analisar.

**Exemplo:**
```json
{
  "id": 1,
  "name": "John Doe"
}
```

No .NET, voc√™ pode usar o namespace `System.Text.Json` para serializar e desserializar JSON.

### **Implementar pagina√ß√£o, filtragem e classifica√ß√£o**

Para endpoints que retornam uma lista de recursos, ofere√ßa suporte √† pagina√ß√£o, filtragem e classifica√ß√£o para melhorar o desempenho e a usabilidade.

**Exemplo:**
```
GET /api/users?page=1&pageSize=10&sortBy=name
```

### **Proteja sua API**

* Use HTTPS para criptografar dados em tr√¢nsito.
* Implementar autentica√ß√£o e autoriza√ß√£o (por exemplo, tokens JWT, OAuth).

### **Documente sua API**

Forne√ßa documenta√ß√£o clara e abrangente para sua API. Ferramentas como o Swagger (OpenAPI) podem ajudar a automatizar esse processo.

[O Swagger morreu? Aqui est√° a alternativa! <br> A Microsoft introduziu uma nova maneira de lidar com a documenta√ß√£o de APIs que torna tudo ainda melhor. Quer saber o que vem por a√≠, as alternativas e como isso afetar√° seu trabalho? Continue lendo para descobrir!](/blog/dotnet-swagger-alternatives-openapi)

## **Construindo uma API RESTful em .NET**

Vamos construir uma API RESTful simples em .NET usando ASP.NET Core.

### **Configurando o Projeto**

1. Crie um novo projeto ASP.NET Core Web API.
2. Adicione `UsersController` para manipular solicita√ß√µes relacionadas ao usu√°rio. 

### Implementando opera√ß√µes CRUD na API Web .NET

Em uma API RESTful, as opera√ß√µes CRUD (Criar, Ler, Atualizar, Excluir) s√£o a base para o gerenciamento de dados. Neste exemplo, implementamos essas opera√ß√µes em uma API Web .NET simples usando uma cole√ß√£o de usu√°rios na mem√≥ria.

### **Configurando o Controlador de API**

O `UsersController` √© decorado com `[ApiController]` e `[Route("api/v1/[controller]")]`, garantindo que ele siga as conven√ß√µes RESTful e tenha uma rota estruturada (`api/v1/users`).

```c#
[ApiController]
[Route("api/v1/[controller]")]
public class UsersController : ControllerBase
```

Este controlador gerencia uma lista est√°tica de usu√°rios, que atua como nosso banco de dados na mem√≥ria.

```c#
private static List<User> _users = new List<User>
{
    new User { Id = 1, Name = "John Doe" },
    new User { Id = 2, Name = "Jane Smith" }
};
```

### **Recuperando todos os usu√°rios**

O endpoint `GetUsers` recupera todos os usu√°rios da lista. Ele retorna um objeto encapsulado `IEnumerable<User>` em uma resposta `Ok()`.

```c#
[HttpGet]
public ActionResult<IEnumerable<User>> GetUsers()
{
    return Ok(_users);
}
```

### **Recuperando um √∫nico usu√°rio por ID**

O endpoint `GetUser` recebe um par√¢metro `id` e procura um usu√°rio correspondente na lista. Se encontrado, retorna o usu√°rio; caso contr√°rio, retorna `NotFound()`.

```c#
[HttpGet("{id}")]
public ActionResult<User> GetUser(int id)
{
    var user = _users.FirstOrDefault(u => u.Id == id);
    if (user == null)
    {
        return NotFound();
    }
    return Ok(user);
}
```

### **Criando um novo usu√°rio**

O m√©todo `CreateUser` aceita um objeto `User` e o adiciona √† lista. A resposta segue as conven√ß√µes RESTful, retornando `CreatedAtAction`, que inclui o URI do usu√°rio rec√©m-criado. 

```c#
[HttpPost]
public ActionResult<User> CreateUser(User user)
{
    _users.Add(user);
    return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
}
```

### **Atualizar um usu√°rio (PUT)**

Este m√©todo atualiza um usu√°rio existente com base no valor `id` fornecido. Se o usu√°rio existir, seu `Name` ser√° atualizado; caso contr√°rio, retornar√° `NotFound()`.

```c#
[HttpPut("{id}")]
public ActionResult UpdateUser(int id, User updatedUser)
{
    var user = _users.FirstOrDefault(u => u.Id == id);
    if (user == null)
    {
        return NotFound();
    }

    user.Name = updatedUser.Name;
    return NoContent();
}
```

**Pontos principais:**
* Use `PUT` porque atualiza um recurso existente.
* Retorna `204 No Content` para indicar uma atualiza√ß√£o bem-sucedida. 
* Garante que o usu√°rio existe antes de modific√°-lo.

### **Excluir um usu√°rio (DELETE)**

Este m√©todo remove um usu√°rio da lista, se ele existir.

```c#
[HttpDelete("{id}")]
public ActionResult DeleteUser(int id)
{
    var user = _users.FirstOrDefault(u => u.Id == id);
    if (user == null)
    {
        return NotFound();
    }

    _users.Remove(user);
    return NoContent();
}
```

**Pontos principais:**
* Use `DELETE` porque remove um recurso.
* Retorna `204 No Content` em caso de sucesso.
* Retorna `404 Not Found` se o usu√°rio n√£o existe.

## Dica:

Se voc√™ quer aprender uma maneira mais completa de criar aplicativos CRUD com .NET, aqui est√£o os artigos perfeitos para voc√™.

[CRUD da API Web do ASP.NET Core 9 com Entity Framework Core - Curso Completo<br>A melhor maneira de realmente dominar qualquer tecnologia √© construir algo com ela ‚Äî e nada supera a cria√ß√£o de opera√ß√µes CRUD (Criar, Ler, Atualizar, Excluir) quando se trata de aprender os conceitos b√°sicos. Essas opera√ß√µes formam a espinha dorsal de quase todos os aplicativos, tornando-as o ponto de partida perfeito para o aprendizado pr√°tico.](/blog/aspnet-core-webapi-crud-with-entity-framework-core-full-course)

## **Conclus√£o**

REST √© um estilo arquitet√¥nico poderoso para a constru√ß√£o de APIs web simples, escal√°veis e f√°ceis de usar. Seguindo os princ√≠pios e as melhores pr√°ticas descritos neste artigo, voc√™ pode projetar APIs RESTful que sejam amig√°veis ao desenvolvedor e prontas para produ√ß√£o.

No pr√≥ximo artigo do [curso .NET Web API Zero to Hero](/courses/dotnet-webapi-zero-to-hero/), aprenderemos sobre Middlewares e Pipeline de Solicita√ß√£o no ASP.NET Core. Fique ligado!

Se voc√™ achou este artigo √∫til, sinta-se √† vontade para compartilh√°-lo com seus colegas desenvolvedores. Boa programa√ß√£o! üöÄ