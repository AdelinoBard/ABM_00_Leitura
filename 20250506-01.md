- **Cita√ß√£o**
  - **T√≠tulo**: Creating a 'pooled' dependency injection lifetime
  - **Autor**: Andrew Lock
  - **Fonte**: Andrew Lock | .NET Escapades
  - **URL**: https://andrewlock.net/creating-a-pooled-dependency-injection-lifetime/?utm_source=bonobopress&utm_medium=newsletter&utm_campaign=2048
  - **Atualizado**: 29 de abril de 2025

---

# Criando um tempo de vida de inje√ß√£o de depend√™ncia 'agrupado'

Esta publica√ß√£o √© uma continua√ß√£o da [minha publica√ß√£o anterior](/going-beyond-singleton-scoped-and-transient-lifetimes/), na qual discuti alguns tempos de vida te√≥ricos/experimentais de inje√ß√£o de depend√™ncia, com base na discuss√£o em um epis√≥dio do [The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/). Na publica√ß√£o anterior, apresentei uma vis√£o geral dos tempos de vida integrados de inje√ß√£o de depend√™ncia e descrevi os tempos de vida adicionais propostos: tenant, pooled e drifter.

A publica√ß√£o anterior forneceu uma vis√£o geral de cada um desses tempos de vida propostos e uma implementa√ß√£o do tempo de vida do drifter (baseado em tempo). Nesta publica√ß√£o, forne√ßo um exemplo do tempo de vida "agrupado".

## [Tempo de vida de inje√ß√£o de depend√™ncia](#dependency-injection-lifetimes)

Este post pretende ser uma continua√ß√£o direta do [post anterior](/going-beyond-singleton-scoped-and-transient-lifetimes/), no qual forne√ßo o contexto completo, mas fornecerei um breve resumo da premissa aqui. Ao registrar servi√ßos no cont√™iner .NET Core DI, voc√™ escolhe um dos tr√™s tempos de vida diferentes.

- Singleton
- Scoped
- Transient

O tempo de vida especificado controla como e quando o cont√™iner DI escolhe criar uma nova inst√¢ncia de um determinado servi√ßo e quando ele retorna uma inst√¢ncia j√° existente do servi√ßo:

- Singleton ‚Äî apenas uma √∫nica inst√¢ncia √© criada
- Scoped ‚Äî uma nova inst√¢ncia √© criada uma vez por "escopo" (normalmente por solicita√ß√£o)
- Transient ‚Äî uma nova inst√¢ncia √© criada sempre que necess√°rio

> Para uma introdu√ß√£o completa √† inje√ß√£o de depend√™ncia no .NET Core, consulte [a documenta√ß√£o da Microsoft](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection) ou [os cap√≠tulos 8](https://livebook.manning.com/book/asp-net-core-in-action-third-edition/chapter-8/) [e 9](https://livebook.manning.com/book/asp-net-core-in-action-third-edition/chapter-9/) do meu livro.

No [epis√≥dio 36 do The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/), Khalid, Maarten e Woody discutem as tr√™s vidas que descrevi acima, fornecendo alguns exemplos de quando voc√™ pode escolher cada uma delas, problemas a serem observados e outras coisas a serem consideradas.

Ao longo do programa, eles tamb√©m discutem o desejo por tr√™s tipos "adicionais" de servi√ßos, que n√£o se encaixavam perfeitamente nos padr√µes de vida √∫til:

- Tenant-scoped services‚Äîeffectively per-tenant singletons
  - Servi√ßos com escopo de locat√°rio ‚Äî efetivamente singletons por locat√°rio
- Time-based (drifter) services‚Äîsingleton services that are replaced periodically
  - Servi√ßos baseados em tempo (drifter) ‚Äî servi√ßos singleton que s√£o substitu√≠dos periodicamente
- Pooled services‚Äîreuses a "pool" of services
  - Servi√ßos agrupados ‚Äî reutiliza um "pool" de servi√ßos

Voc√™ pode ler uma maneira de implementar servi√ßos com escopo de locat√°rio [nesta s√©rie de blogs](https://michael-mckenna.com/multi-tenant-asp-dot-net-8-tenant-resolution/) de Michael McKenna e eu mostrei uma implementa√ß√£o do tempo de vida baseado em tempo/drifter [na minha postagem anterior](/going-beyond-singleton-scoped-and-transient-lifetimes/#implementing-a-simple-time-based-lifetime-service). Nesta postagem, analiso uma poss√≠vel implementa√ß√£o de um tempo de vida agrupado.

## [Requisitos de tempo de vida agrupados](#pooled-lifetime-requirements)

Woody mencionou o pooling no epis√≥dio do podcast como uma forma de reduzir aloca√ß√µes e, assim, melhorar o desempenho. O tempo de vida agrupado (inspirado no recurso de pooling `DbContext` do EF Core) tornaria esse recurso um recurso geral de DI, permitindo o pooling de servi√ßos "arbitr√°rios".

Em geral, considerei que os requisitos para esse recurso eram:

- Servi√ßos agrupados devem ter sem√¢ntica "com escopo", ou seja, quando uma inst√¢ncia agrupada √© usada, ela deve ser usada para todo o escopo da solicita√ß√£o e n√£o deve ser usada por solicita√ß√µes paralelas.
- Quando um servi√ßo em pool √© solicitado, o DI deve usar uma inst√¢ncia em pool primeiro, se dispon√≠vel. Se n√£o houver inst√¢ncias em pool dispon√≠veis, o cont√™iner do DI deve criar uma nova inst√¢ncia.
- Quando o escopo for descartado, os servi√ßos agrupados dever√£o ser devolvidos ao pool.
- O cont√™iner DI deve agrupar no m√°ximo `N` inst√¢ncias do servi√ßo. Quando uma inst√¢ncia √© retornada, se j√° houver `N` inst√¢ncias no pool, a inst√¢ncia retornada deve ser descartada (chamando `Dispose()` se necess√°rio).
- Os servi√ßos agrupados devem implementar a interface `IResetableService`, que cont√©m um √∫nico m√©todo `Reset`.
- Quando uma inst√¢ncia √© retornada ao pool, o pool deve chamar `Reset()` na inst√¢ncia. Isso deve redefinir a inst√¢ncia, para que seja seguro reutiliz√°-la em outra solicita√ß√£o.
- Al√©m de `IResetableService`, n√£o deve haver outros requisitos "adicionais" no servi√ßo agrupado.
- Se um servi√ßo implementar `IDisposable`, ele dever√° ser descartado se n√£o for retornado ao pool.

Considerei esses como os principais requisitos, mas para facilitar um pouco a implementa√ß√£o da minha prova de conceito, adicionei alguns anti-requisitos:

- √â permitido retornar um tipo "wrapper" para acessar o servi√ßo agrupado (semelhante a como a abstra√ß√£o `IOptions<>` funciona no ASP.NET Core).
- Ignore os requisitos `async` por enquanto, ou seja, n√£o h√° necessidade de `ResetAsync()` ou suporte a `IAsyncDisposable`.
- N√£o se preocupe com a configura√ß√£o do pool, ou seja, permita um tamanho m√°ximo "fixo" para o pool.

Isso abrange a maioria dos pontos importantes de comportamento. Na pr√≥xima se√ß√£o, mostrarei um exemplo de implementa√ß√£o que atende a todos eles.

> Observe que optei por _n√£o_ usar `ObjectPool<T>` para explorar isso. N√£o por qualquer raz√£o de princ√≠pio, eu apenas esperava ter uma API ligeiramente diferente. Voc√™ pode ver uma implementa√ß√£o semelhante que usa `ObjectPool<T>` na [documenta√ß√£o da Microsoft](https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-9.0).

## [Implementando um servi√ßo de vida √∫til agrupado](#implementing-a-pooled-lifetime-service)

Existem 5 partes m√≥veis diferentes na implementa√ß√£o:

- `IResetableService`‚Äî A interface que os servi√ßos redefin√≠veis devem implementar
- `IPooledService<T>`‚Äî A interface usada para acessar uma inst√¢ncia do item `T` (an√°logo a `IOptions<T>`)
- `PooledService<T>`‚Äî A implementa√ß√£o interna de `IPooledService<T>`
- `DependencyPool<T>`‚Äî A implementa√ß√£o de pooling, respons√°vel pelo aluguel e retorno de `IPooledService<T>`
- `PoolingExtensions`‚Äî M√©todos auxiliares para adicionar os servi√ßos necess√°rios ao cont√™iner DI.

Agora vamos analisar cada um deles por vez

### [`IResetableService`](#iresettableservice)

Este √© o √∫nico requisito no pr√≥prio servi√ßo agrupado, e h√° apenas um m√©todo para implementar, `Reset()`:

```c#
public interface IResettableService
{
    void Reset();
}
```

---

- Prop√≥sito: Definir um contrato para servi√ßos que podem ser redefinidos/resetados.
- Comportamento: A interface exige a implementa√ß√£o de um m√©todo `Reset()` que permite reinicializar o estado do servi√ßo.
- Code:
  - `public interface IResettableService` - declara uma interface p√∫blica `IResettableService`
  - `void Reset();` - define um m√©todo `Reset()` sem par√¢metros e sem retorno que deve ser implementado

---

Quando chamado, `Reset()` deve redefinir o servi√ßo para seu estado "original", para que ele possa ser reutilizado quando removido do pool. Se compararmos isso com `DbContext` (a inspira√ß√£o original para a ideia do pool), √© aqui que o rastreamento de altera√ß√µes seria redefinido, por exemplo.

### [`IPooledService<T>`](#ipooledservicet)

A interface `IPooledService<T>` √© como o aplicativo recupera principalmente inst√¢ncias de um servi√ßo agrupado `T`. √â o tipo que voc√™ injeta nos seus construtores de servi√ßo e √© como voc√™ acessa inst√¢ncias de `T`, semelhante a como `IOptions<T>` funciona para configura√ß√£o:

```c#
public interface IPooledService<out T>
    where T : IResettableService
{
    T Value { get; }
}
```

---

- Prop√≥sito: Definir uma interface gen√©rica para servi√ßos poolados que fornecem um valor de tipo `T`.
- Comportamento: A interface especifica uma propriedade `Value` que retorna um objeto do tipo `T`, garantindo que `T` implemente `IResettableService`.
- Code:
  - `public interface IPooledService<out T>` - declara uma interface p√∫blica gen√©rica `IPooledService` com tipo covariante `T`
  - `where T : IResettableService` - restri√ß√£o de tipo: `T` deve implementar `IResettableService`
  - `T Value { get; }` - define uma propriedade somente leitura `Value` que retorna um objeto do tipo `T`

---

Como voc√™ pode ver acima, o servi√ßo `T` deve implementar `IResetableService` e pode ser acessado por meio da propriedade `Value`. Por exemplo, voc√™ pode us√°-lo em um servi√ßo dependente como este:

```c#
public class DependentService
{
    private readonly IMyService _myService;
    public DependentService(IPooledService<IMyService> pooled)
    {
        // Extract the value from the IPooledService<T>
        _myService = pooled.Value;
    }
}
```

---

- Prop√≥sito: Prover uma classe que depende de um servi√ßo obtido de um pool de servi√ßos.
- Comportamento: A classe recebe um servi√ßo poolado via inje√ß√£o de depend√™ncia e extrai o servi√ßo real para uso interno.
- Code:
  - `public class DependentService` - define a classe p√∫blica `DependentService`
  - `private readonly IMyService _myService;` - declara um campo privado readonly do tipo `IMyService`
  - `public DependentService(IPooledService<IMyService> pooled)` - construtor que recebe uma inst√¢ncia de `IPooledService<IMyService>`
  - `_myService = pooled.Value;` - atribui o valor extra√≠do do servi√ßo poolado ao campo `_myService`

---

Esse n√≠vel de indire√ß√£o √© um pouco irritante do ponto de vista pr√°tico, mas achei que era um mal necess√°rio criar um tempo de vida de pooling _generalizado_. Todas as alternativas que consegui imaginar que n√£o exigiriam `IPooledService<T>`, em vez disso, exigiriam que `IResetableService` fizesse muito mais trabalho, o que eu queria evitar nesta implementa√ß√£o.

### [`Servi√ßoPooled<T>`](#servi√ßopooledt)

`PooledService<T>` √© a implementa√ß√£o `interna` de `IPooledService<T>`:

```c#
internal class PooledService<T> : IPooledService<T>, IDisposable
    where T : IResettableService
{
    private readonly DependencyPool<T> _pool;

    public PooledService(DependencyPool<T> pool)
    {
        _pool = pool;
        // Rent a service from the pool
        Value = _pool.Rent();
    }

    public T Value { get; }

    void IDisposable.Dispose()
    {
        // When the PooledService<T> is disposed,
        // the service is returned to the pool
        _pool.Return(Value);
    }
}
```

---

- Prop√≥sito: Implementar um servi√ßo poolado que gerencia o ciclo de vida de inst√¢ncias reutiliz√°veis de um tipo T.
- Comportamento: Aluga inst√¢ncias do pool no construtor e as devolve quando descartado, implementando o padr√£o Object Pool.
- Code:
  - `internal class PooledService<T> : IPooledService<T>, IDisposable` - classe interna que implementa IPooledService<T> e IDisposable
  - `where T : IResettableService` - restri√ß√£o que T deve implementar IResettableService
  - `private readonly DependencyPool<T> _pool` - campo privado para armazenar a refer√™ncia ao pool
  - `public PooledService(DependencyPool<T> pool)` - construtor que recebe e armazena o pool
  - `Value = _pool.Rent()` - aluga uma inst√¢ncia do pool e atribui √† propriedade Value
  - `public T Value { get; }` - propriedade que exp√µe a inst√¢ncia alugada
  - `void IDisposable.Dispose()` - implementa√ß√£o expl√≠cita de IDisposable
  - `_pool.Return(Value)` - devolve a inst√¢ncia ao pool quando descartado

---

Como voc√™ pode ver no c√≥digo acima, a implementa√ß√£o de `PooledService<T>` depende de `DependencyPool<T>`, que examinaremos em detalhes em breve. O servi√ßo aluga uma inst√¢ncia de `T` do pool no construtor. O cont√™iner DI ent√£o descartar√° automaticamente o `PooledService<T>` quando o escopo do servi√ßo terminar, o que retornar√° o servi√ßo `T` ao pool.

### [`DependencyPool<T>`](#dependencypoolt)

A inst√¢ncia `DependencyPool<T>` √© onde a maior parte do trabalho de implementa√ß√£o acontece. O `DependencyPool<T>` √© respons√°vel por:

- Cria√ß√£o de novas inst√¢ncias do servi√ßo `<T>` se n√£o houver nenhuma no pool.
- Adicionando servi√ßos retornados ao pool.
- Retornando servi√ßos agrupados quando dispon√≠veis.
- Descartar servi√ßos que n√£o podem ser adicionados ao pool.

```c#
internal class DependencyPool<T>(IServiceProvider provider) : IDisposable
    where T : IResettableService
{
    private int _count = 0; // The number of instances in the pool
    private int _maxPoolSize = 3; // TODO: Set via options
    private readonly ConcurrentQueue<T> _pool = new();
    private readonly Func<T> _factory = () => ActivatorUtilities.CreateInstance<T>(provider);

    public T Rent()
    {
        // Try to retrieve an item from the pool
        if (_pool.TryDequeue(out var service))
        {
            // the
            Interlocked.Decrement(ref _count);
            return service;
        }

        // No services in the pool
        return _factory();
    }

    public void Return(T service)
    {
        if (Interlocked.Increment(ref _count) <= _maxPoolSize)
        {
            // there was space in the pool, so reset and return the service
            service.Reset();
            _pool.Enqueue(service);
        }
        else
        {
            // The maximum pool size has been exceeded
            // We incremented when attempting to return, so reverse that
            Interlocked.Decrement(ref _count);
            (service as IDisposable)?.Dispose();
        }
    }

    public void Dispose()
    {
        // If the pool itself is disposed, dispose all the pooled services
        _maxPoolSize = 0;

        while (_pool.TryDequeue(out var service))
        {
            (service as IDisposable)?.Dispose();
        }
    }
}
```

---

- Prop√≥sito: Implementar um pool de depend√™ncias thread-safe para gerenciar inst√¢ncias reutiliz√°veis de servi√ßos que implementam IResettableService.
- Comportamento: Controla a cria√ß√£o, aloca√ß√£o, devolu√ß√£o e descarte de inst√¢ncias, mantendo um n√∫mero m√°ximo definido no pool e garantindo opera√ß√µes thread-safe.
- Code:
  - `internal class DependencyPool<T>(IServiceProvider provider) : IDisposable` - classe interna gen√©rica que recebe IServiceProvider no construtor e implementa IDisposable
  - `where T : IResettableService` - restri√ß√£o onde T deve implementar IResettableService
  - `private int _count = 0;` - contador de inst√¢ncias atualmente no pool
  - `private int _maxPoolSize = 3;` - tamanho m√°ximo do pool (hardcoded temporariamente)
  - `private readonly ConcurrentQueue<T> _pool = new();` - fila thread-safe para armazenar as inst√¢ncias
  - `private readonly Func<T> _factory = () => ActivatorUtilities.CreateInstance<T>(provider);` - factory method para criar novas inst√¢ncias
  - `public T Rent()` - m√©todo para alocar uma inst√¢ncia do pool (ou criar nova se vazio)
    - `_pool.TryDequeue(out var service)` - tenta remover item da fila thread-safe
    - `Interlocked.Decrement(ref _count);` - decrementa atomicamente o contador
  - `public void Return(T service)` - m√©todo para devolver inst√¢ncia ao pool
    - `Interlocked.Increment(ref _count)` - incrementa atomicamente o contador
    - `service.Reset();` - reseta o estado do servi√ßo antes de retornar ao pool
    - `_pool.Enqueue(service);` - adiciona de volta √† fila thread-safe
    - `(service as IDisposable)?.Dispose();` - descarta o servi√ßo se exceder o tamanho m√°ximo
  - `public void Dispose()` - implementa√ß√£o de IDisposable para limpeza
    - `_maxPoolSize = 0;` - desabilita o pool
    - `while (_pool.TryDequeue(out var service))` - esvazia a fila
    - `(service as IDisposable)?.Dispose();` - descarta cada servi√ßo

---

A implementa√ß√£o √© relativamente simples, mas com alguns pontos interessantes:

- Um `IServiceProvider` √© passado no construtor e √© usado com `ActivatorUtilities.CreateInstance()` para criar uma "f√°brica" `Func<T>` para criar inst√¢ncias do servi√ßo `T`.
- O n√∫mero de inst√¢ncias agrupadas √© armazenado em `_count` e √© armazenado separadamente de `ConcurrentQueue<T>`. O uso de `Interlocked.Increment()` e `Interlocked.Decrement()` garante que n√£o excedamos o tamanho m√°ximo do pool.
- O tamanho m√°ximo do pool na implementa√ß√£o acima √© fixado em `3`, mas isso pode ser facilmente configurado.
- Quando o pr√≥prio `DependencyPool<T>` √© descartado, o pool garante que nenhuma outra inst√¢ncia possa ser alugada e descarta todas as inst√¢ncias atualmente agrupadas.

### [`Extens√µes de Pool`](#extens√µes de pool)

J√° cobrimos praticamente todas as partes m√≥veis, a √∫ltima etapa √© registrar tudo no cont√™iner DI. Temos apenas dois servi√ßos que precisamos registrar aqui: `DependencyPool<T>` e `IPooledService<T>`.

```c#
public static class PoolingExtensions
{
    public static IServiceCollection AddScopedPooling<T>(this IServiceCollection services)
        where T : class, IResettableService
    {
        services.TryAddSingleton<DependencyPool<T>>();
        services.TryAddScoped<IPooledService<T>, PooledService<T>>();

        return services;
    }
}
```

---

- Prop√≥sito: Prover m√©todos de extens√£o para configurar inje√ß√£o de depend√™ncia com pooling de servi√ßos.
- Comportamento: Registra servi√ßos necess√°rios para implementar o padr√£o de pooling no container DI, configurando DependencyPool como singleton e PooledService como scoped.
- Code:
  - `public static class PoolingExtensions` - classe est√°tica contendo m√©todos de extens√£o para DI
  - `public static IServiceCollection AddScopedPooling<T>(this IServiceCollection services)` - m√©todo de extens√£o para IServiceCollection que configura pooling
  - `where T : class, IResettableService` - restri√ß√£o onde T deve ser classe e implementar IResettableService
  - `services.TryAddSingleton<DependencyPool<T>>();` - registra DependencyPool como singleton (se n√£o registrado)
  - `services.TryAddScoped<IPooledService<T>, PooledService<T>>();` - registra PooledService como scoped (se n√£o registrado)

---

Observe que _n√£o_ registramos `T` como um servi√ßo que voc√™ pode extrair diretamente do cont√™iner; voc√™ sempre precisa recuperar um `IPooledService<T>` e acessar o `T` chamando `Value`. Voc√™ _talvez_ pense que poderia lidar com isso automaticamente no cont√™iner, fazendo algo como o seguinte:

```c#
services.AddScoped(s => s.GetRequiredService<IPooledService<T>>().Value);
```

Mas, infelizmente, isso n√£o funciona. Ao fazer com que o cont√™iner DI retorne o `T` diretamente, o cont√™iner DI descartar√° o `T` automaticamente quando o escopo terminar. N√£o √© isso que queremos para servi√ßos agrupados ‚Äî o servi√ßo agrupado ser√° distribu√≠do novamente, e n√£o queremos que ele seja _descartado_, mas sim _redefinido_.

> Um lembrete de que uma alternativa a essa implementa√ß√£o seria usar a implementa√ß√£o `ObjectPool<T>`, conforme descrito nos [documentos da Microsoft](https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-9.0).

Ok, temos uma implementa√ß√£o completa, √© hora de test√°-la!

## [Testando a implementa√ß√£o](#testing-the-implementation)

Para testar o servi√ßo, estou usando um servi√ßo de teste semelhante ao que usei [no post anterior](/going-beyond-singleton-scoped-and-transient-lifetimes/#testing-out-the-timed-dependencies), onde cada inst√¢ncia recebe um ID diferente para seu tempo de vida, para que possamos ver facilmente quando novas inst√¢ncias s√£o criadas:

```c#
public class TestService : IResettableService, IDisposable
{
    private static int _id = 0;

    public int Id { get; } = Interlocked.Increment(ref _id);

    public void Dispose() => Console.WriteLine($"Disposing service: {Id}");

    public void Reset() => Console.WriteLine($"Resetting service: {Id}");
}
```

---

- Prop√≥sito: Implementar um servi√ßo de teste que demonstra o comportamento de reset e dispose para uso com pooling.
- Comportamento: Mant√©m um ID √∫nico por inst√¢ncia e implementa as opera√ß√µes b√°sicas requeridas por IResettableService e IDisposable com logging.
- Code:
  - `public class TestService : IResettableService, IDisposable` - classe p√∫blica que implementa IResettableService e IDisposable
  - `private static int _id = 0;` - contador est√°tico para gerar IDs √∫nicos
  - `public int Id { get; } = Interlocked.Increment(ref _id);` - propriedade Id com incremento at√¥mico thread-safe
  - `public void Dispose() => Console.WriteLine($"Disposing service: {Id}");` - implementa√ß√£o de IDisposable com log
  - `public void Reset() => Console.WriteLine($"Resetting service: {Id}");` - implementa√ß√£o de IResettableService com log

---

Al√©m disso, adicionei alguns logs b√°sicos aos m√©todos `Reset()` e `Dispose()` para que possamos rastrear mais facilmente o que est√° acontecendo.

Para testar, criei um pequeno aplicativo de console. O aplicativo cria uma `ServiceCollection`, compila um `IServiceProvider` e, em seguida, gera v√°rios escopos em paralelo. Para cada escopo, ele recupera uma inst√¢ncia de `TestService` e imprime seu `Id`. Em seguida, ele descarta todos os escopos. Em seguida, executamos a mesma sequ√™ncia novamente:

```c#
var collection = new ServiceCollection();
collection.AddScopedPooling<TestService>();
var services = collection.BuildServiceProvider();

Console.WriteLine("Generating scopes A")
GenerateScopes(services);
Console.WriteLine()
Console.WriteLine("Generating scopes B")
GenerateScopes(services);

static void GenerateScopes(IServiceProvider services)
{
    var count = 5;
    List<IServiceScope> scopes = new(count);

    // Simulate 5 parallel requests
    for (int i = 0; i < count; i++)
    {
        // Create a scope, but don't dispose it yet
        var scope = services.CreateScope();
        scopes.Add(scope);
        // Retrieve an instance of the pooled service
        var service = scope.ServiceProvider.GetRequiredService<IPooledService<TestService>>().Value;
        Console.WriteLine($"Received service: {service.Id}");
    }

    foreach (var scope in scopes)
    {
        scope.Dispose();
    }
}
```

Quando executamos esse c√≥digo, obtemos a seguinte sequ√™ncia:

```bash
Generating scopes A
Received value: 1
Received value: 2
Received value: 3
Received value: 4
Received value: 5
Resetting service: 1
Resetting service: 2
Resetting service: 3
Disposing service: 4
Disposing service: 5

Generating scopes B
Received value: 1
Received value: 2
Received value: 3
Received value: 6
Received value: 7
Resetting service: 1
Resetting service: 2
Resetting service: 3
Disposing service: 6
Disposing service: 7
```

Observando os Ids impressos, podemos ver que isso funciona conforme o esperado:

- 5 novas inst√¢ncias s√£o criadas para satisfazer os 5 escopos paralelos.
- Quando os escopos s√£o descartados, o m√°ximo de 3 inst√¢ncias s√£o redefinidas e armazenadas no pool. Os dois servi√ßos restantes s√£o descartados, pois n√£o podem ser agrupados.
- Quando a sequ√™ncia for executada novamente, as 3 primeiras solicita√ß√µes usar√£o inst√¢ncias agrupadas. As duas inst√¢ncias restantes devem ser criadas, fornecendo os IDs `6` e `7`.
- Quando os escopos s√£o descartados, novamente as 3 inst√¢ncias s√£o agrupadas e as 2 restantes s√£o descartadas.

Ent√£o parece que a implementa√ß√£o est√° funcionando como esperado, mas acho que vale a pena pensar sobre as limita√ß√µes e considerar se voc√™ _deve_ usar algo assim.

## [Limita√ß√µes na implementa√ß√£o do tempo de vida agrupado](#limitations-in-the-pooled-lifetime-implementation)

A inspira√ß√£o para o tempo de vida do pooling foi o pooling de `DbContext` do EF Core, mas a implementa√ß√£o acima √© fundamentalmente um pouco diferente. O `DbContext` foi projetado para "saber" sobre pooling, e sua implementa√ß√£o interna tem conhecimento de `DbContextLease`, que rastreia a origem de inst√¢ncias de `DbContext` etc. Isso contrasta com a implementa√ß√£o acima, na qual a classe de implementa√ß√£o n√£o precisa saber sobre os detalhes do pooling (al√©m de fornecer uma implementa√ß√£o `Reset()`).

O resultado l√≠quido da implementa√ß√£o de `DbContext` √© que o _uso_ de `DbContext` √© id√™ntico, independentemente de voc√™ usar ou n√£o o pooling. Isso contrasta novamente com a implementa√ß√£o deste post, na qual voc√™ deve usar a abstra√ß√£o intermedi√°ria `IPooledService<T>`.

Outro ponto a considerar na implementa√ß√£o acima √© que seus servi√ßos agrupados _n√£o_ podem depender de servi√ßos com escopo, mesmo que os servi√ßos se comportem de forma semelhante aos pr√≥prios servi√ßos com escopo. Isso ocorre porque as inst√¢ncias "vivem" por mais tempo do que um √∫nico escopo de servi√ßo, portanto, o √∫nico tempo de vida que realmente faz sentido para depend√™ncias √© o singleton, ou possivelmente o transiente.

Outro aspecto a considerar √© que o pool √© muito simplista. O sistema funciona por ordem de chegada, tanto no aluguel quanto na devolu√ß√£o. Uma vez que os itens estejam no pool, eles permanecer√£o l√° at√© que sejam alugados novamente. Voc√™ _poderia_ melhorar tudo isso, √© claro, mas, ao complicar as coisas, corre o risco de eliminar os benef√≠cios que o pooling poderia trazer.

## [O pooling √© realmente √∫til?](#is-pooling-actually-useful-)

A inspira√ß√£o original para o tempo de vida do pool foi o pool `DbContext` do EF Core, para o qual um [benchmark de thread √∫nico](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/ContextPooling.cs) mostra que o pool pode melhorar o desempenho e reduzir a aloca√ß√£o:

| M√©todo | NumBlogs | M√©dia | Erro | DesvioPadr√£o | Gera√ß√£o 0 | Gera√ß√£o 1 | Gera√ß√£o 2 | Alocado |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| SemContextPooling | 1 | 701,6 n√≥s | 26,62 n√≥s | 78,48 n√≥s | 11,7188 | - | - | 50,38 KB |
| WithContextPooling | 1 | 350,1 n√≥s | 6,80 n√≥s | 14,64 n√≥s | 0,9766 | - | - | 4,63 KB |

No entanto, s√≥ porque √© ben√©fico para o EF Core em geral, n√£o significa _necessariamente_ que ser√° sempre ben√©fico. Isso √© explicitamente mencionado pela Microsoft em [uma publica√ß√£o de blog que discute o agrupamento de inst√¢ncias `ValueTask`](https://devblogs.microsoft.com/dotnet/async-valuetask-pooling-in-net-5/), l√° no .NET 5.

> Ao empregar tal pool, o desenvolvedor aposta que pode implementar um alocador personalizado (que √©, na verdade, o que um pool √©) melhor do que o alocador de GC de uso geral. Vencer o GC n√£o √© trivial. Mas um desenvolvedor pode conseguir, dado o conhecimento que tem do seu cen√°rio espec√≠fico.

A aloca√ß√£o de mem√≥ria em .NET √© muito eficiente; o tempo de execu√ß√£o √© _r√°pido_ na aloca√ß√£o de mem√≥ria e at√© mesmo na limpeza de objetos pequenos. Portanto, embora o pooling signifique que o alocador geralmente n√£o precisa ser executado tanto, n√£o √© exatamente a√≠ que voc√™ obt√©m melhorias de desempenho.

Uma poss√≠vel fonte de melhorias de desempenho com o pooling pode surgir quando os objetos alocados s√£o grandes. Objetos grandes geralmente s√£o mais caros para o coletor de lixo, pois quanto mais mem√≥ria alocada, mais frequentemente o coletor de lixo precisa ser executado e mais trabalho ele precisa fazer (para zerar a mem√≥ria, etc.).

O pooling tamb√©m pode ser uma vantagem se a constru√ß√£o dos objetos for cara. Isso pode ocorrer porque o pr√≥prio construtor faz muito trabalho. Tamb√©m pode ocorrer porque o cont√™iner DI n√£o precisa calcular e reconstruir o gr√°fico de depend√™ncias completo do objeto sempre que ele √© solicitado. Ou pode ocorrer porque voc√™ precisa usar um recurso limitado do sistema operacional.

No entanto, h√° problemas interessantes a serem considerados aqui, que _poderiam_ minar quaisquer melhorias na coleta de lixo que voc√™ esperaria ver com o pooling.

Em primeiro lugar, se o m√©todo `Reset()` tiver que realizar mais trabalho do que o coletor de lixo (GC) faria para colet√°-lo, voc√™ imediatamente perde qualquer vantagem que poderia esperar obter do pooling. Mas h√° um problema ainda mais sutil.

O .NET GC √© um coletor de lixo geracional. Objetos rec√©m-alocados s√£o colocados na Gera√ß√£o 0 e normalmente podem ser limpos rapidamente. Se um determinado objeto sobreviver √† coleta de lixo porque ainda est√° em uso, ele √© promovido para a Gera√ß√£o 1. Os objetos com vida √∫til mais longa s√£o eventualmente promovidos para a Gera√ß√£o 2.

Em geral, quanto maior a gera√ß√£o do GC, mais caro √© a limpeza. Idealmente, o GC tenta escanear todos os objetos da Gera√ß√£o 0 para ver se ainda est√£o ativos. Isso funciona bem porque geralmente objetos da Gera√ß√£o 0 referenciam _outros_ objetos da Gera√ß√£o 0. A situa√ß√£o fica complicada quando um objeto da Gera√ß√£o **2** tem uma refer√™ncia a um objeto da Gera√ß√£o 0. Ent√£o, de repente, o GC precisa verificar os objetos da Gera√ß√£o 2 para descobrir se esse objeto da Gera√ß√£o 0 pode ser coletado. E isso √© _muito_ mais caro.

E o que o pooling faz? Faz com que os objetos durem mais, ent√£o eles acabam na Gera√ß√£o 2. Se esses objetos contiverem refer√™ncias a objetos de vida curta... ent√£o, de repente, voc√™ torna os GCs _muito_ mais caros. üò¨

> Essas quest√µes (e outras) s√£o discutidas por Stephen Toub com Scott Hanselman no [v√≠deo Deep .NET no ArrayPool](https://learn.microsoft.com/en-us/shows/on-dotnet/lets-build-our-own-arraypool-deep-dotnet-with-stephen-scott#time=39m51s).

Concluindo: voc√™ deveria usar isso? Provavelmente n√£o, mas eu gostei de explorar üòÄ

## [Resumo](#resumo)

Este post √© uma continua√ß√£o do meu post anterior, no qual discuti alguns tempos de vida te√≥ricos/experimentais de inje√ß√£o de depend√™ncia, com base na discuss√£o em um epis√≥dio do The Breakpoint Show (https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/ ). Neste post, apresentei uma poss√≠vel implementa√ß√£o de um tempo de vida "agrupado", que poderia ser usado com servi√ßos arbitr√°rios. A implementa√ß√£o tem uma s√©rie de limita√ß√µes que analiso e uso como desculpa para discutir se o agrupamento de objetos gen√©ricos faz sentido ou n√£o.
